package proc

// Code generated by gen.
// 本文件是对应 wilds 的处理器实现文件。
// 框架代码由 gen 生成，具体实现需要手工填写。
// 再次生成时会合并原有实现。

import (
	"battleservice/src/services/battle/match"
	"battleservice/src/services/battle/roommgr"
	"battleservice/src/services/battle/roommgr/room"
	"battleservice/src/services/battle/sess"
	"battleservice/src/services/battle/usercmd"

	assert "github.com/aurelien-rainone/assertgo"
	"github.com/cihub/seelog"

	"github.com/giant-tech/go-service/base/net/inet"
	"github.com/giant-tech/go-service/framework/errormsg"
	"github.com/giant-tech/go-service/framework/iserver"
	"github.com/giant-tech/go-service/framework/msgdef"
)

// ProcBattle 是消息处理类(Processor).
type ProcBattle struct {
	sess         inet.ISession // 一般都需要包含session对象
	IServiceBase iserver.IServiceBase
	sessPlayer   *sess.SessionPlayer // 网络会话对应的玩家对象

	// 进入房间才会有
	room        *room.Room
	scenePlayer IScenePlayer // 场景内执行动作的玩家对象
}

type IScenePlayer interface {
	OnCastSkill(op *usercmd.MsgCastSkill)
	OnNetMove(op *usercmd.MsgMove)
	OnNetReLife(op *usercmd.MsgRelife)
	OnRun(op *usercmd.MsgRun)
	OnSceneChat(op *usercmd.MsgSceneChat)
}

var matchMaker = match.NewMatchMaker()

// RegisterMsgProcFunctions 克隆自身并注册消息处理函数.
func (p *ProcBattle) RegisterMsgProcFunctions(sess inet.ISession) interface{} {
	assert.True(sess != nil, "session is nil")
	result := &ProcBattle{
		sess:         sess,
		IServiceBase: p.IServiceBase,
	}

	sess.RegMsgProc(result)
	sess.AddOnClosed(result.OnClosed)

	//seelog.Debugf("ProcBattle.RegisterMsgProcFunctions, p: %p, sess: %p ", result, sess)

	return result
}

// MsgProcLoginReq  MsgProcLoginReq
func (p *ProcBattle) MsgProcLoginReq(msg *msgdef.LoginReq) {
	seelog.Debugf("Begin MsgProcLoginReq, UID: %d, sess: %p", msg.UID, p.sess)

	retMsg := &msgdef.LoginResp{}

	p.sess.SetVerified()

	//发送送登录验证成功消息
	retMsg.Result = uint32(errormsg.ReturnTypeSUCCESS)
	p.sess.Send(retMsg)

	//seelog.Debugf("Finish MsgProcLoginReq, UID: %d, p: %p, entity: %p", msg.UID, p, entity)
}

// OnClosed 关闭回调
func (p *ProcBattle) OnClosed() {
	// 会话断开时动作...

	//seelog.Infof("ProcBattle OnClosed: %d %s, p: %p, entity: %p", p.sess.GetID(), p.sess.RemoteAddr(), p, p.entity)

	seelog.Debugf("ProcBattle OnClosed, sess: %p", p.sess)

	// 会话断开时动作...
	seelog.Infof("Closed %d %s", p.sess.GetID(), p.sess.RemoteAddr())
	matchMaker.DelPlayer(p.sessPlayer)

	if p.room == nil {
		return
	}

	// 下线从房间删除
	p.room.PostToRemovePlayerById(p.sessPlayer.PlayerID())
}

// MsgProcCallMsg CallMsg消息处理
func (p *ProcBattle) MsgProcCallMsg(msg *msgdef.CallMsg) {
	//seelog.Infof("MsgProcCallMsg, Seq:%d, MethodName:%s, stype: %d", msg.Seq, msg.MethodName, msg.SType)

}

func (p *ProcBattle) postToLocalService(srvID uint64, msg *msgdef.CallMsg) error {
	var err error
	localS := iserver.GetLocalServiceMgr().GetLocalService(srvID)
	if localS != nil {
		if msg.IsSync {
			retData := localS.PostCallMsgAndWait(msg)

			retMsg := &msgdef.CallRespMsg{}
			retMsg.Seq = msg.Seq
			retMsg.RetData = retData.Ret

			if retData.Err != nil {
				retMsg.ErrString = retData.Err.Error()
				err = retData.Err
			}

			p.sess.Send(retMsg)
		} else {
			err = localS.PostCallMsg(msg)
			if err != nil {
				seelog.Error("service proxy PostCallMsg err: ", err)
			}
		}
	} else {
		//TODO:
	}

	return err
}

// IsPlaying 返回玩家是否处于正常游戏中.
func (p *ProcBattle) IsPlaying() bool {
	return p.room != nil && !p.room.IsClosed() && p.scenePlayer != nil
}

// CheckPlaying 检查并返回玩家是否处于正常游戏中.
func (p *ProcBattle) CheckPlaying() bool {
	if p.IsPlaying() {
		return true
	}

	if p.SetRoom() == false {
		return false
	}
	if p.SetScenePlayer() == false {
		return false
	}
	return p.IsPlaying()
}

// SetRoom 检查并设置房间. 返回是否设置.
func (p *ProcBattle) SetRoom() bool {
	if p.room != nil {
		return true
	}

	roomID := p.sessPlayer.RoomID()
	p.room = roommgr.GetMe().GetRoomByID(roomID)
	return p.room != nil
}

// SetScenePlayer 检查并设置scenePlayer成员. 返回是否设置.
// 需要等待房间线程返回。
func (p *ProcBattle) SetScenePlayer() bool {
	if p.scenePlayer != nil {
		return true
	}
	if p.room == nil {
		return false
	}

	// 阻塞式获取 scenePlayer 对象
	room := p.room
	playerID := p.sessPlayer.PlayerID()
	itf := room.Call(func() interface{} {
		// 在房间协程中执行
		return IScenePlayer(room.GetScenePlayer(playerID))
	})
	p.scenePlayer = itf.(IScenePlayer)
	return p.scenePlayer != nil // scenePlayer 可能还未创建
}

// func (p *ProcBattle) MsgProc_MsgLogin(msg *usercmd.MsgLogin) {
// 	seelog.Infof("[登录] 收到登录请求 %s, %d, %s", p.sess.RemoteAddr(), p.sess.GetID(), msg.Name)
// 	p.sessPlayer.SetName(msg.Name)
// 	matchMaker.AddPlayer(p.sessPlayer)
// }

// func (p *ProcBattle) MsgProc_MsgMove(msg *usercmd.MsgMove) {
// 	if p.CheckPlaying() == false {
// 		return
// 	}

// 	p.room.PostAction(func() {
// 		p.scenePlayer.OnNetMove(msg)
// 	})
// }

// func (p *ProcBattle) MsgProc_MsgRun(msg *usercmd.MsgRun) {
// 	if p.CheckPlaying() == false {
// 		return
// 	}

// 	p.room.PostAction(func() {
// 		p.scenePlayer.OnRun(msg)
// 	})
// }

// func (p *ProcBattle) MsgProc_MsgRelife(msg *usercmd.MsgRelife) {
// 	if p.CheckPlaying() == false {
// 		return
// 	}
// 	p.room.PostAction(func() {
// 		p.scenePlayer.OnNetReLife(msg)
// 	})
// }

// func (p *ProcBattle) MsgProc_ClientHeartBeat(msg *usercmd.ClientHeartBeat) {
// 	p.sess.Send(msg)
// }

// func (p *ProcBattle) MsgProc_MsgSceneChat(msg *usercmd.MsgSceneChat) {
// 	if p.CheckPlaying() == false {
// 		return
// 	}

// 	p.room.PostAction(func() {
// 		p.scenePlayer.OnSceneChat(msg)
// 	})
// }

// func (p *ProcBattle) MsgProc_MsgCastSkill(msg *usercmd.MsgCastSkill) {
// 	if p.CheckPlaying() == false {
// 		return
// 	}
// 	p.room.PostAction(func() {
// 		p.scenePlayer.OnCastSkill(msg)
// 	})
// }
