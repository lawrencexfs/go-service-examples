// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: game.proto

package protoMsg

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// s-->c 玩家主数据
type UserMainDataNotify struct {
	Uid                  uint64   `protobuf:"varint,1,opt,name=uid" json:"uid"`
	Name                 string   `protobuf:"bytes,2,opt,name=name" json:"name"`
	Coins                uint64   `protobuf:"varint,3,opt,name=coins" json:"coins"`
	Diams                uint64   `protobuf:"varint,4,opt,name=diams" json:"diams"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserMainDataNotify) Reset()         { *m = UserMainDataNotify{} }
func (m *UserMainDataNotify) String() string { return proto.CompactTextString(m) }
func (*UserMainDataNotify) ProtoMessage()    {}
func (*UserMainDataNotify) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{0}
}
func (m *UserMainDataNotify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserMainDataNotify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserMainDataNotify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UserMainDataNotify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserMainDataNotify.Merge(dst, src)
}
func (m *UserMainDataNotify) XXX_Size() int {
	return m.Size()
}
func (m *UserMainDataNotify) XXX_DiscardUnknown() {
	xxx_messageInfo_UserMainDataNotify.DiscardUnknown(m)
}

var xxx_messageInfo_UserMainDataNotify proto.InternalMessageInfo

func (m *UserMainDataNotify) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UserMainDataNotify) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UserMainDataNotify) GetCoins() uint64 {
	if m != nil {
		return m.Coins
	}
	return 0
}

func (m *UserMainDataNotify) GetDiams() uint64 {
	if m != nil {
		return m.Diams
	}
	return 0
}

// 坐标
type Vector3 struct {
	X                    float32  `protobuf:"fixed32,1,opt,name=x" json:"x"`
	Y                    float32  `protobuf:"fixed32,2,opt,name=y" json:"y"`
	Z                    float32  `protobuf:"fixed32,3,opt,name=z" json:"z"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Vector3) Reset()         { *m = Vector3{} }
func (m *Vector3) String() string { return proto.CompactTextString(m) }
func (*Vector3) ProtoMessage()    {}
func (*Vector3) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{1}
}
func (m *Vector3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vector3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vector3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Vector3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vector3.Merge(dst, src)
}
func (m *Vector3) XXX_Size() int {
	return m.Size()
}
func (m *Vector3) XXX_DiscardUnknown() {
	xxx_messageInfo_Vector3.DiscardUnknown(m)
}

var xxx_messageInfo_Vector3 proto.InternalMessageInfo

func (m *Vector3) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *Vector3) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *Vector3) GetZ() float32 {
	if m != nil {
		return m.Z
	}
	return 0
}

type T_Object struct {
	Baseid               uint32   `protobuf:"varint,1,opt,name=baseid" json:"baseid"`
	Thisid               uint64   `protobuf:"varint,2,opt,name=thisid" json:"thisid"`
	Count                uint32   `protobuf:"varint,3,opt,name=count" json:"count"`
	Gunreform            []uint32 `protobuf:"varint,4,rep,name=gunreform" json:"gunreform,omitempty"`
	Bullet               uint32   `protobuf:"varint,5,opt,name=bullet" json:"bullet"`
	Reducedam            uint32   `protobuf:"varint,6,opt,name=reducedam" json:"reducedam"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *T_Object) Reset()         { *m = T_Object{} }
func (m *T_Object) String() string { return proto.CompactTextString(m) }
func (*T_Object) ProtoMessage()    {}
func (*T_Object) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{2}
}
func (m *T_Object) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *T_Object) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_T_Object.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *T_Object) XXX_Merge(src proto.Message) {
	xxx_messageInfo_T_Object.Merge(dst, src)
}
func (m *T_Object) XXX_Size() int {
	return m.Size()
}
func (m *T_Object) XXX_DiscardUnknown() {
	xxx_messageInfo_T_Object.DiscardUnknown(m)
}

var xxx_messageInfo_T_Object proto.InternalMessageInfo

func (m *T_Object) GetBaseid() uint32 {
	if m != nil {
		return m.Baseid
	}
	return 0
}

func (m *T_Object) GetThisid() uint64 {
	if m != nil {
		return m.Thisid
	}
	return 0
}

func (m *T_Object) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *T_Object) GetGunreform() []uint32 {
	if m != nil {
		return m.Gunreform
	}
	return nil
}

func (m *T_Object) GetBullet() uint32 {
	if m != nil {
		return m.Bullet
	}
	return 0
}

func (m *T_Object) GetReducedam() uint32 {
	if m != nil {
		return m.Reducedam
	}
	return 0
}

// 玩家地图数据
type ChracterMapDataInfo struct {
	Uid                  uint64    `protobuf:"varint,1,opt,name=uid" json:"uid"`
	Name                 string    `protobuf:"bytes,2,opt,name=name" json:"name"`
	Level                uint32    `protobuf:"varint,3,opt,name=level" json:"level"`
	Pos                  *Vector3  `protobuf:"bytes,4,opt,name=pos" json:"pos,omitempty"`
	Mvspeed              float32   `protobuf:"fixed32,5,opt,name=mvspeed" json:"mvspeed"`
	Maxhp                uint32    `protobuf:"varint,6,opt,name=maxhp" json:"maxhp"`
	Hp                   uint32    `protobuf:"varint,7,opt,name=hp" json:"hp"`
	Orientation          float32   `protobuf:"fixed32,8,opt,name=orientation" json:"orientation"`
	Weapon               *T_Object `protobuf:"bytes,9,opt,name=weapon" json:"weapon,omitempty"`
	Secweapon            *T_Object `protobuf:"bytes,10,opt,name=secweapon" json:"secweapon,omitempty"`
	Armors               []uint32  `protobuf:"varint,11,rep,name=armors" json:"armors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ChracterMapDataInfo) Reset()         { *m = ChracterMapDataInfo{} }
func (m *ChracterMapDataInfo) String() string { return proto.CompactTextString(m) }
func (*ChracterMapDataInfo) ProtoMessage()    {}
func (*ChracterMapDataInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{3}
}
func (m *ChracterMapDataInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChracterMapDataInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChracterMapDataInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ChracterMapDataInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChracterMapDataInfo.Merge(dst, src)
}
func (m *ChracterMapDataInfo) XXX_Size() int {
	return m.Size()
}
func (m *ChracterMapDataInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ChracterMapDataInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ChracterMapDataInfo proto.InternalMessageInfo

func (m *ChracterMapDataInfo) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ChracterMapDataInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ChracterMapDataInfo) GetLevel() uint32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *ChracterMapDataInfo) GetPos() *Vector3 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *ChracterMapDataInfo) GetMvspeed() float32 {
	if m != nil {
		return m.Mvspeed
	}
	return 0
}

func (m *ChracterMapDataInfo) GetMaxhp() uint32 {
	if m != nil {
		return m.Maxhp
	}
	return 0
}

func (m *ChracterMapDataInfo) GetHp() uint32 {
	if m != nil {
		return m.Hp
	}
	return 0
}

func (m *ChracterMapDataInfo) GetOrientation() float32 {
	if m != nil {
		return m.Orientation
	}
	return 0
}

func (m *ChracterMapDataInfo) GetWeapon() *T_Object {
	if m != nil {
		return m.Weapon
	}
	return nil
}

func (m *ChracterMapDataInfo) GetSecweapon() *T_Object {
	if m != nil {
		return m.Secweapon
	}
	return nil
}

func (m *ChracterMapDataInfo) GetArmors() []uint32 {
	if m != nil {
		return m.Armors
	}
	return nil
}

// s-->c 公告
type ChatNotify struct {
	Content              string   `protobuf:"bytes,1,opt,name=content" json:"content"`
	Type                 uint32   `protobuf:"varint,2,opt,name=type" json:"type"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChatNotify) Reset()         { *m = ChatNotify{} }
func (m *ChatNotify) String() string { return proto.CompactTextString(m) }
func (*ChatNotify) ProtoMessage()    {}
func (*ChatNotify) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{4}
}
func (m *ChatNotify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChatNotify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChatNotify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ChatNotify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChatNotify.Merge(dst, src)
}
func (m *ChatNotify) XXX_Size() int {
	return m.Size()
}
func (m *ChatNotify) XXX_DiscardUnknown() {
	xxx_messageInfo_ChatNotify.DiscardUnknown(m)
}

var xxx_messageInfo_ChatNotify proto.InternalMessageInfo

func (m *ChatNotify) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *ChatNotify) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

// s-->c 区域通知
type ZoneNotify struct {
	Type                 uint32   `protobuf:"varint,1,opt,name=type" json:"type"`
	Center               *Vector3 `protobuf:"bytes,2,opt,name=center" json:"center,omitempty"`
	Radius               float32  `protobuf:"fixed32,3,opt,name=radius" json:"radius"`
	Interval             uint32   `protobuf:"varint,4,opt,name=interval" json:"interval"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZoneNotify) Reset()         { *m = ZoneNotify{} }
func (m *ZoneNotify) String() string { return proto.CompactTextString(m) }
func (*ZoneNotify) ProtoMessage()    {}
func (*ZoneNotify) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{5}
}
func (m *ZoneNotify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZoneNotify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZoneNotify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ZoneNotify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZoneNotify.Merge(dst, src)
}
func (m *ZoneNotify) XXX_Size() int {
	return m.Size()
}
func (m *ZoneNotify) XXX_DiscardUnknown() {
	xxx_messageInfo_ZoneNotify.DiscardUnknown(m)
}

var xxx_messageInfo_ZoneNotify proto.InternalMessageInfo

func (m *ZoneNotify) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ZoneNotify) GetCenter() *Vector3 {
	if m != nil {
		return m.Center
	}
	return nil
}

func (m *ZoneNotify) GetRadius() float32 {
	if m != nil {
		return m.Radius
	}
	return 0
}

func (m *ZoneNotify) GetInterval() uint32 {
	if m != nil {
		return m.Interval
	}
	return 0
}

// c-->s 换弹
type ChangeBulletReq struct {
	Full                 bool     `protobuf:"varint,1,opt,name=full" json:"full"`
	Pos                  uint32   `protobuf:"varint,2,opt,name=pos" json:"pos"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChangeBulletReq) Reset()         { *m = ChangeBulletReq{} }
func (m *ChangeBulletReq) String() string { return proto.CompactTextString(m) }
func (*ChangeBulletReq) ProtoMessage()    {}
func (*ChangeBulletReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{6}
}
func (m *ChangeBulletReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeBulletReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangeBulletReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ChangeBulletReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeBulletReq.Merge(dst, src)
}
func (m *ChangeBulletReq) XXX_Size() int {
	return m.Size()
}
func (m *ChangeBulletReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeBulletReq.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeBulletReq proto.InternalMessageInfo

func (m *ChangeBulletReq) GetFull() bool {
	if m != nil {
		return m.Full
	}
	return false
}

func (m *ChangeBulletReq) GetPos() uint32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

// s-->c 换弹
type ChangeBulletRet struct {
	Uid                  uint64   `protobuf:"varint,1,opt,name=uid" json:"uid"`
	Bullet               uint32   `protobuf:"varint,2,opt,name=bullet" json:"bullet"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChangeBulletRet) Reset()         { *m = ChangeBulletRet{} }
func (m *ChangeBulletRet) String() string { return proto.CompactTextString(m) }
func (*ChangeBulletRet) ProtoMessage()    {}
func (*ChangeBulletRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{7}
}
func (m *ChangeBulletRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeBulletRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangeBulletRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ChangeBulletRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeBulletRet.Merge(dst, src)
}
func (m *ChangeBulletRet) XXX_Size() int {
	return m.Size()
}
func (m *ChangeBulletRet) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeBulletRet.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeBulletRet proto.InternalMessageInfo

func (m *ChangeBulletRet) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ChangeBulletRet) GetBullet() uint32 {
	if m != nil {
		return m.Bullet
	}
	return 0
}

type TeamMemberInfo struct {
	Uid                  uint64   `protobuf:"varint,1,opt,name=uid" json:"uid"`
	Name                 string   `protobuf:"bytes,2,opt,name=name" json:"name"`
	MemState             uint32   `protobuf:"varint,3,opt,name=memState" json:"memState"`
	Modelid              uint64   `protobuf:"varint,4,opt,name=modelid" json:"modelid"`
	Intotime             int64    `protobuf:"varint,5,opt,name=intotime" json:"intotime"`
	Slot                 uint32   `protobuf:"varint,6,opt,name=slot" json:"slot"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TeamMemberInfo) Reset()         { *m = TeamMemberInfo{} }
func (m *TeamMemberInfo) String() string { return proto.CompactTextString(m) }
func (*TeamMemberInfo) ProtoMessage()    {}
func (*TeamMemberInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{8}
}
func (m *TeamMemberInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TeamMemberInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TeamMemberInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TeamMemberInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TeamMemberInfo.Merge(dst, src)
}
func (m *TeamMemberInfo) XXX_Size() int {
	return m.Size()
}
func (m *TeamMemberInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TeamMemberInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TeamMemberInfo proto.InternalMessageInfo

func (m *TeamMemberInfo) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *TeamMemberInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TeamMemberInfo) GetMemState() uint32 {
	if m != nil {
		return m.MemState
	}
	return 0
}

func (m *TeamMemberInfo) GetModelid() uint64 {
	if m != nil {
		return m.Modelid
	}
	return 0
}

func (m *TeamMemberInfo) GetIntotime() int64 {
	if m != nil {
		return m.Intotime
	}
	return 0
}

func (m *TeamMemberInfo) GetSlot() uint32 {
	if m != nil {
		return m.Slot
	}
	return 0
}

// s-->c 同步组队信息
type SyncTeamInfoRet struct {
	Id                   uint64            `protobuf:"varint,1,opt,name=id" json:"id"`
	TeamState            uint32            `protobuf:"varint,2,opt,name=teamState" json:"teamState"`
	Memberinfo           []*TeamMemberInfo `protobuf:"bytes,3,rep,name=memberinfo" json:"memberinfo,omitempty"`
	Leaderid             uint64            `protobuf:"varint,4,opt,name=leaderid" json:"leaderid"`
	Teamtype             uint32            `protobuf:"varint,5,opt,name=teamtype" json:"teamtype"`
	Automatch            uint32            `protobuf:"varint,6,opt,name=automatch" json:"automatch"`
	Mapid                uint32            `protobuf:"varint,7,opt,name=mapid" json:"mapid"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SyncTeamInfoRet) Reset()         { *m = SyncTeamInfoRet{} }
func (m *SyncTeamInfoRet) String() string { return proto.CompactTextString(m) }
func (*SyncTeamInfoRet) ProtoMessage()    {}
func (*SyncTeamInfoRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{9}
}
func (m *SyncTeamInfoRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncTeamInfoRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncTeamInfoRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SyncTeamInfoRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncTeamInfoRet.Merge(dst, src)
}
func (m *SyncTeamInfoRet) XXX_Size() int {
	return m.Size()
}
func (m *SyncTeamInfoRet) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncTeamInfoRet.DiscardUnknown(m)
}

var xxx_messageInfo_SyncTeamInfoRet proto.InternalMessageInfo

func (m *SyncTeamInfoRet) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SyncTeamInfoRet) GetTeamState() uint32 {
	if m != nil {
		return m.TeamState
	}
	return 0
}

func (m *SyncTeamInfoRet) GetMemberinfo() []*TeamMemberInfo {
	if m != nil {
		return m.Memberinfo
	}
	return nil
}

func (m *SyncTeamInfoRet) GetLeaderid() uint64 {
	if m != nil {
		return m.Leaderid
	}
	return 0
}

func (m *SyncTeamInfoRet) GetTeamtype() uint32 {
	if m != nil {
		return m.Teamtype
	}
	return 0
}

func (m *SyncTeamInfoRet) GetAutomatch() uint32 {
	if m != nil {
		return m.Automatch
	}
	return 0
}

func (m *SyncTeamInfoRet) GetMapid() uint32 {
	if m != nil {
		return m.Mapid
	}
	return 0
}

// 副本中组队玩家信息
type SyncRoomTeamPlayerItem struct {
	Id                   uint64   `protobuf:"varint,1,opt,name=id" json:"id"`
	Hp                   uint32   `protobuf:"varint,2,opt,name=hp" json:"hp"`
	Pos                  *Vector3 `protobuf:"bytes,3,opt,name=pos" json:"pos,omitempty"`
	State                uint32   `protobuf:"varint,4,opt,name=state" json:"state"`
	Rota                 *Vector3 `protobuf:"bytes,5,opt,name=rota" json:"rota,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SyncRoomTeamPlayerItem) Reset()         { *m = SyncRoomTeamPlayerItem{} }
func (m *SyncRoomTeamPlayerItem) String() string { return proto.CompactTextString(m) }
func (*SyncRoomTeamPlayerItem) ProtoMessage()    {}
func (*SyncRoomTeamPlayerItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{10}
}
func (m *SyncRoomTeamPlayerItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncRoomTeamPlayerItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncRoomTeamPlayerItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SyncRoomTeamPlayerItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncRoomTeamPlayerItem.Merge(dst, src)
}
func (m *SyncRoomTeamPlayerItem) XXX_Size() int {
	return m.Size()
}
func (m *SyncRoomTeamPlayerItem) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncRoomTeamPlayerItem.DiscardUnknown(m)
}

var xxx_messageInfo_SyncRoomTeamPlayerItem proto.InternalMessageInfo

func (m *SyncRoomTeamPlayerItem) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SyncRoomTeamPlayerItem) GetHp() uint32 {
	if m != nil {
		return m.Hp
	}
	return 0
}

func (m *SyncRoomTeamPlayerItem) GetPos() *Vector3 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *SyncRoomTeamPlayerItem) GetState() uint32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *SyncRoomTeamPlayerItem) GetRota() *Vector3 {
	if m != nil {
		return m.Rota
	}
	return nil
}

// s-->c Room场景中初始化组队信息
type SymcRoomTeamInfoRet struct {
	Item                 []*SyncRoomTeamPlayerItem `protobuf:"bytes,1,rep,name=item" json:"item,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *SymcRoomTeamInfoRet) Reset()         { *m = SymcRoomTeamInfoRet{} }
func (m *SymcRoomTeamInfoRet) String() string { return proto.CompactTextString(m) }
func (*SymcRoomTeamInfoRet) ProtoMessage()    {}
func (*SymcRoomTeamInfoRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{11}
}
func (m *SymcRoomTeamInfoRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SymcRoomTeamInfoRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SymcRoomTeamInfoRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SymcRoomTeamInfoRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SymcRoomTeamInfoRet.Merge(dst, src)
}
func (m *SymcRoomTeamInfoRet) XXX_Size() int {
	return m.Size()
}
func (m *SymcRoomTeamInfoRet) XXX_DiscardUnknown() {
	xxx_messageInfo_SymcRoomTeamInfoRet.DiscardUnknown(m)
}

var xxx_messageInfo_SymcRoomTeamInfoRet proto.InternalMessageInfo

func (m *SymcRoomTeamInfoRet) GetItem() []*SyncRoomTeamPlayerItem {
	if m != nil {
		return m.Item
	}
	return nil
}

// s-->c 场景道具
type ItemProp struct {
	Baseid               uint32   `protobuf:"varint,1,opt,name=baseid" json:"baseid"`
	Id                   uint64   `protobuf:"varint,2,opt,name=id" json:"id"`
	Num                  uint32   `protobuf:"varint,3,opt,name=num" json:"num"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ItemProp) Reset()         { *m = ItemProp{} }
func (m *ItemProp) String() string { return proto.CompactTextString(m) }
func (*ItemProp) ProtoMessage()    {}
func (*ItemProp) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{12}
}
func (m *ItemProp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemProp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemProp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ItemProp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemProp.Merge(dst, src)
}
func (m *ItemProp) XXX_Size() int {
	return m.Size()
}
func (m *ItemProp) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemProp.DiscardUnknown(m)
}

var xxx_messageInfo_ItemProp proto.InternalMessageInfo

func (m *ItemProp) GetBaseid() uint32 {
	if m != nil {
		return m.Baseid
	}
	return 0
}

func (m *ItemProp) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ItemProp) GetNum() uint32 {
	if m != nil {
		return m.Num
	}
	return 0
}

// s-->c 刷新补给箱内道具
type RefreshBoxObjNotify struct {
	Id                   uint64      `protobuf:"varint,1,opt,name=id" json:"id"`
	Data                 []*ItemProp `protobuf:"bytes,2,rep,name=data" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *RefreshBoxObjNotify) Reset()         { *m = RefreshBoxObjNotify{} }
func (m *RefreshBoxObjNotify) String() string { return proto.CompactTextString(m) }
func (*RefreshBoxObjNotify) ProtoMessage()    {}
func (*RefreshBoxObjNotify) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{13}
}
func (m *RefreshBoxObjNotify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefreshBoxObjNotify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RefreshBoxObjNotify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RefreshBoxObjNotify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefreshBoxObjNotify.Merge(dst, src)
}
func (m *RefreshBoxObjNotify) XXX_Size() int {
	return m.Size()
}
func (m *RefreshBoxObjNotify) XXX_DiscardUnknown() {
	xxx_messageInfo_RefreshBoxObjNotify.DiscardUnknown(m)
}

var xxx_messageInfo_RefreshBoxObjNotify proto.InternalMessageInfo

func (m *RefreshBoxObjNotify) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RefreshBoxObjNotify) GetData() []*ItemProp {
	if m != nil {
		return m.Data
	}
	return nil
}

type HeadProp struct {
	Baseid               uint32   `protobuf:"varint,1,opt,name=baseid" json:"baseid"`
	Reducedam            uint32   `protobuf:"varint,2,opt,name=reducedam" json:"reducedam"`
	Maxreduce            uint32   `protobuf:"varint,3,opt,name=maxreduce" json:"maxreduce"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeadProp) Reset()         { *m = HeadProp{} }
func (m *HeadProp) String() string { return proto.CompactTextString(m) }
func (*HeadProp) ProtoMessage()    {}
func (*HeadProp) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{14}
}
func (m *HeadProp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeadProp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeadProp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HeadProp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeadProp.Merge(dst, src)
}
func (m *HeadProp) XXX_Size() int {
	return m.Size()
}
func (m *HeadProp) XXX_DiscardUnknown() {
	xxx_messageInfo_HeadProp.DiscardUnknown(m)
}

var xxx_messageInfo_HeadProp proto.InternalMessageInfo

func (m *HeadProp) GetBaseid() uint32 {
	if m != nil {
		return m.Baseid
	}
	return 0
}

func (m *HeadProp) GetReducedam() uint32 {
	if m != nil {
		return m.Reducedam
	}
	return 0
}

func (m *HeadProp) GetMaxreduce() uint32 {
	if m != nil {
		return m.Maxreduce
	}
	return 0
}

type BodyProp struct {
	Baseid               uint32   `protobuf:"varint,1,opt,name=baseid" json:"baseid"`
	Reducedam            uint32   `protobuf:"varint,2,opt,name=reducedam" json:"reducedam"`
	Maxreduce            uint32   `protobuf:"varint,3,opt,name=maxreduce" json:"maxreduce"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BodyProp) Reset()         { *m = BodyProp{} }
func (m *BodyProp) String() string { return proto.CompactTextString(m) }
func (*BodyProp) ProtoMessage()    {}
func (*BodyProp) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{15}
}
func (m *BodyProp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BodyProp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BodyProp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BodyProp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BodyProp.Merge(dst, src)
}
func (m *BodyProp) XXX_Size() int {
	return m.Size()
}
func (m *BodyProp) XXX_DiscardUnknown() {
	xxx_messageInfo_BodyProp.DiscardUnknown(m)
}

var xxx_messageInfo_BodyProp proto.InternalMessageInfo

func (m *BodyProp) GetBaseid() uint32 {
	if m != nil {
		return m.Baseid
	}
	return 0
}

func (m *BodyProp) GetReducedam() uint32 {
	if m != nil {
		return m.Reducedam
	}
	return 0
}

func (m *BodyProp) GetMaxreduce() uint32 {
	if m != nil {
		return m.Maxreduce
	}
	return 0
}

type BackPackProp struct {
	Baseid               uint32   `protobuf:"varint,1,opt,name=baseid" json:"baseid"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BackPackProp) Reset()         { *m = BackPackProp{} }
func (m *BackPackProp) String() string { return proto.CompactTextString(m) }
func (*BackPackProp) ProtoMessage()    {}
func (*BackPackProp) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{16}
}
func (m *BackPackProp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackPackProp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackPackProp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BackPackProp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackPackProp.Merge(dst, src)
}
func (m *BackPackProp) XXX_Size() int {
	return m.Size()
}
func (m *BackPackProp) XXX_DiscardUnknown() {
	xxx_messageInfo_BackPackProp.DiscardUnknown(m)
}

var xxx_messageInfo_BackPackProp proto.InternalMessageInfo

func (m *BackPackProp) GetBaseid() uint32 {
	if m != nil {
		return m.Baseid
	}
	return 0
}

// TLog 玩家注册消息
type PlayerRegister struct {
	GameSvrID            string   `protobuf:"bytes,1,opt,name=GameSvrID" json:"GameSvrID"`
	DtEventTime          string   `protobuf:"bytes,2,opt,name=DtEventTime" json:"DtEventTime"`
	VGameAppID           string   `protobuf:"bytes,3,opt,name=VGameAppID" json:"VGameAppID"`
	PlatID               uint32   `protobuf:"varint,4,opt,name=PlatID" json:"PlatID"`
	IZoneAreaID          uint32   `protobuf:"varint,5,opt,name=IZoneAreaID" json:"IZoneAreaID"`
	VOpenID              string   `protobuf:"bytes,6,opt,name=VOpenID" json:"VOpenID"`
	TelecomOper          string   `protobuf:"bytes,7,opt,name=TelecomOper" json:"TelecomOper"`
	RegChannel           string   `protobuf:"bytes,8,opt,name=RegChannel" json:"RegChannel"`
	LoginChannel         uint32   `protobuf:"varint,9,opt,name=LoginChannel" json:"LoginChannel"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayerRegister) Reset()         { *m = PlayerRegister{} }
func (m *PlayerRegister) String() string { return proto.CompactTextString(m) }
func (*PlayerRegister) ProtoMessage()    {}
func (*PlayerRegister) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{17}
}
func (m *PlayerRegister) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerRegister) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerRegister.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PlayerRegister) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerRegister.Merge(dst, src)
}
func (m *PlayerRegister) XXX_Size() int {
	return m.Size()
}
func (m *PlayerRegister) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerRegister.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerRegister proto.InternalMessageInfo

func (m *PlayerRegister) GetGameSvrID() string {
	if m != nil {
		return m.GameSvrID
	}
	return ""
}

func (m *PlayerRegister) GetDtEventTime() string {
	if m != nil {
		return m.DtEventTime
	}
	return ""
}

func (m *PlayerRegister) GetVGameAppID() string {
	if m != nil {
		return m.VGameAppID
	}
	return ""
}

func (m *PlayerRegister) GetPlatID() uint32 {
	if m != nil {
		return m.PlatID
	}
	return 0
}

func (m *PlayerRegister) GetIZoneAreaID() uint32 {
	if m != nil {
		return m.IZoneAreaID
	}
	return 0
}

func (m *PlayerRegister) GetVOpenID() string {
	if m != nil {
		return m.VOpenID
	}
	return ""
}

func (m *PlayerRegister) GetTelecomOper() string {
	if m != nil {
		return m.TelecomOper
	}
	return ""
}

func (m *PlayerRegister) GetRegChannel() string {
	if m != nil {
		return m.RegChannel
	}
	return ""
}

func (m *PlayerRegister) GetLoginChannel() uint32 {
	if m != nil {
		return m.LoginChannel
	}
	return 0
}

// TLog 玩家登录消息
type PlayerLogin struct {
	GameSvrID            string   `protobuf:"bytes,1,opt,name=GameSvrID" json:"GameSvrID"`
	DtEventTime          string   `protobuf:"bytes,2,opt,name=DtEventTime" json:"DtEventTime"`
	VGameAppID           string   `protobuf:"bytes,3,opt,name=VGameAppID" json:"VGameAppID"`
	PlatID               uint32   `protobuf:"varint,4,opt,name=PlatID" json:"PlatID"`
	IZoneAreaID          uint32   `protobuf:"varint,5,opt,name=IZoneAreaID" json:"IZoneAreaID"`
	VOpenID              string   `protobuf:"bytes,6,opt,name=VOpenID" json:"VOpenID"`
	Level                uint32   `protobuf:"varint,7,opt,name=Level" json:"Level"`
	PlayerFriendsNum     uint32   `protobuf:"varint,8,opt,name=PlayerFriendsNum" json:"PlayerFriendsNum"`
	ClientVersion        string   `protobuf:"bytes,9,opt,name=ClientVersion" json:"ClientVersion"`
	SystemHardware       string   `protobuf:"bytes,10,opt,name=SystemHardware" json:"SystemHardware"`
	TelecomOper          string   `protobuf:"bytes,11,opt,name=TelecomOper" json:"TelecomOper"`
	Network              string   `protobuf:"bytes,12,opt,name=Network" json:"Network"`
	LoginChannel         uint32   `protobuf:"varint,13,opt,name=LoginChannel" json:"LoginChannel"`
	VRoleID              string   `protobuf:"bytes,14,opt,name=VRoleID" json:"VRoleID"`
	VRoleName            string   `protobuf:"bytes,15,opt,name=VRoleName" json:"VRoleName"`
	RegChannel           string   `protobuf:"bytes,16,opt,name=RegChannel" json:"RegChannel"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayerLogin) Reset()         { *m = PlayerLogin{} }
func (m *PlayerLogin) String() string { return proto.CompactTextString(m) }
func (*PlayerLogin) ProtoMessage()    {}
func (*PlayerLogin) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{18}
}
func (m *PlayerLogin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerLogin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerLogin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PlayerLogin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerLogin.Merge(dst, src)
}
func (m *PlayerLogin) XXX_Size() int {
	return m.Size()
}
func (m *PlayerLogin) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerLogin.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerLogin proto.InternalMessageInfo

func (m *PlayerLogin) GetGameSvrID() string {
	if m != nil {
		return m.GameSvrID
	}
	return ""
}

func (m *PlayerLogin) GetDtEventTime() string {
	if m != nil {
		return m.DtEventTime
	}
	return ""
}

func (m *PlayerLogin) GetVGameAppID() string {
	if m != nil {
		return m.VGameAppID
	}
	return ""
}

func (m *PlayerLogin) GetPlatID() uint32 {
	if m != nil {
		return m.PlatID
	}
	return 0
}

func (m *PlayerLogin) GetIZoneAreaID() uint32 {
	if m != nil {
		return m.IZoneAreaID
	}
	return 0
}

func (m *PlayerLogin) GetVOpenID() string {
	if m != nil {
		return m.VOpenID
	}
	return ""
}

func (m *PlayerLogin) GetLevel() uint32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *PlayerLogin) GetPlayerFriendsNum() uint32 {
	if m != nil {
		return m.PlayerFriendsNum
	}
	return 0
}

func (m *PlayerLogin) GetClientVersion() string {
	if m != nil {
		return m.ClientVersion
	}
	return ""
}

func (m *PlayerLogin) GetSystemHardware() string {
	if m != nil {
		return m.SystemHardware
	}
	return ""
}

func (m *PlayerLogin) GetTelecomOper() string {
	if m != nil {
		return m.TelecomOper
	}
	return ""
}

func (m *PlayerLogin) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *PlayerLogin) GetLoginChannel() uint32 {
	if m != nil {
		return m.LoginChannel
	}
	return 0
}

func (m *PlayerLogin) GetVRoleID() string {
	if m != nil {
		return m.VRoleID
	}
	return ""
}

func (m *PlayerLogin) GetVRoleName() string {
	if m != nil {
		return m.VRoleName
	}
	return ""
}

func (m *PlayerLogin) GetRegChannel() string {
	if m != nil {
		return m.RegChannel
	}
	return ""
}

// TLog 玩家登出消息
type PlayerLogout struct {
	GameSvrID            string   `protobuf:"bytes,1,opt,name=GameSvrID" json:"GameSvrID"`
	DtEventTime          string   `protobuf:"bytes,2,opt,name=DtEventTime" json:"DtEventTime"`
	VGameAppID           string   `protobuf:"bytes,3,opt,name=VGameAppID" json:"VGameAppID"`
	PlatID               uint32   `protobuf:"varint,4,opt,name=PlatID" json:"PlatID"`
	IZoneAreaID          uint32   `protobuf:"varint,5,opt,name=IZoneAreaID" json:"IZoneAreaID"`
	VOpenID              string   `protobuf:"bytes,6,opt,name=VOpenID" json:"VOpenID"`
	OnlineTime           uint32   `protobuf:"varint,7,opt,name=OnlineTime" json:"OnlineTime"`
	Level                uint32   `protobuf:"varint,8,opt,name=Level" json:"Level"`
	PlayerFriendsNum     uint32   `protobuf:"varint,9,opt,name=PlayerFriendsNum" json:"PlayerFriendsNum"`
	ClientVersion        string   `protobuf:"bytes,10,opt,name=ClientVersion" json:"ClientVersion"`
	SystemHardware       string   `protobuf:"bytes,11,opt,name=SystemHardware" json:"SystemHardware"`
	TelecomOper          string   `protobuf:"bytes,12,opt,name=TelecomOper" json:"TelecomOper"`
	Network              string   `protobuf:"bytes,13,opt,name=Network" json:"Network"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayerLogout) Reset()         { *m = PlayerLogout{} }
func (m *PlayerLogout) String() string { return proto.CompactTextString(m) }
func (*PlayerLogout) ProtoMessage()    {}
func (*PlayerLogout) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{19}
}
func (m *PlayerLogout) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerLogout) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerLogout.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PlayerLogout) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerLogout.Merge(dst, src)
}
func (m *PlayerLogout) XXX_Size() int {
	return m.Size()
}
func (m *PlayerLogout) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerLogout.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerLogout proto.InternalMessageInfo

func (m *PlayerLogout) GetGameSvrID() string {
	if m != nil {
		return m.GameSvrID
	}
	return ""
}

func (m *PlayerLogout) GetDtEventTime() string {
	if m != nil {
		return m.DtEventTime
	}
	return ""
}

func (m *PlayerLogout) GetVGameAppID() string {
	if m != nil {
		return m.VGameAppID
	}
	return ""
}

func (m *PlayerLogout) GetPlatID() uint32 {
	if m != nil {
		return m.PlatID
	}
	return 0
}

func (m *PlayerLogout) GetIZoneAreaID() uint32 {
	if m != nil {
		return m.IZoneAreaID
	}
	return 0
}

func (m *PlayerLogout) GetVOpenID() string {
	if m != nil {
		return m.VOpenID
	}
	return ""
}

func (m *PlayerLogout) GetOnlineTime() uint32 {
	if m != nil {
		return m.OnlineTime
	}
	return 0
}

func (m *PlayerLogout) GetLevel() uint32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *PlayerLogout) GetPlayerFriendsNum() uint32 {
	if m != nil {
		return m.PlayerFriendsNum
	}
	return 0
}

func (m *PlayerLogout) GetClientVersion() string {
	if m != nil {
		return m.ClientVersion
	}
	return ""
}

func (m *PlayerLogout) GetSystemHardware() string {
	if m != nil {
		return m.SystemHardware
	}
	return ""
}

func (m *PlayerLogout) GetTelecomOper() string {
	if m != nil {
		return m.TelecomOper
	}
	return ""
}

func (m *PlayerLogout) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

type MailObject struct {
	Id                   uint32   `protobuf:"varint,1,opt,name=id" json:"id"`
	Num                  uint32   `protobuf:"varint,2,opt,name=num" json:"num"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MailObject) Reset()         { *m = MailObject{} }
func (m *MailObject) String() string { return proto.CompactTextString(m) }
func (*MailObject) ProtoMessage()    {}
func (*MailObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{20}
}
func (m *MailObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MailObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MailObject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MailObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MailObject.Merge(dst, src)
}
func (m *MailObject) XXX_Size() int {
	return m.Size()
}
func (m *MailObject) XXX_DiscardUnknown() {
	xxx_messageInfo_MailObject.DiscardUnknown(m)
}

var xxx_messageInfo_MailObject proto.InternalMessageInfo

func (m *MailObject) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MailObject) GetNum() uint32 {
	if m != nil {
		return m.Num
	}
	return 0
}

type MailInfo struct {
	Mailid               uint64        `protobuf:"varint,1,opt,name=mailid" json:"mailid"`
	Mailtype             uint32        `protobuf:"varint,2,opt,name=mailtype" json:"mailtype"`
	Gettime              uint64        `protobuf:"varint,3,opt,name=gettime" json:"gettime"`
	Haveread             bool          `protobuf:"varint,4,opt,name=haveread" json:"haveread"`
	Title                string        `protobuf:"bytes,5,opt,name=title" json:"title"`
	Text                 string        `protobuf:"bytes,6,opt,name=text" json:"text"`
	Url                  string        `protobuf:"bytes,7,opt,name=url" json:"url"`
	Objs                 []*MailObject `protobuf:"bytes,8,rep,name=objs" json:"objs,omitempty"`
	Haveget              bool          `protobuf:"varint,9,opt,name=haveget" json:"haveget"`
	Button               string        `protobuf:"bytes,10,opt,name=button" json:"button"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *MailInfo) Reset()         { *m = MailInfo{} }
func (m *MailInfo) String() string { return proto.CompactTextString(m) }
func (*MailInfo) ProtoMessage()    {}
func (*MailInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{21}
}
func (m *MailInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MailInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MailInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MailInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MailInfo.Merge(dst, src)
}
func (m *MailInfo) XXX_Size() int {
	return m.Size()
}
func (m *MailInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MailInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MailInfo proto.InternalMessageInfo

func (m *MailInfo) GetMailid() uint64 {
	if m != nil {
		return m.Mailid
	}
	return 0
}

func (m *MailInfo) GetMailtype() uint32 {
	if m != nil {
		return m.Mailtype
	}
	return 0
}

func (m *MailInfo) GetGettime() uint64 {
	if m != nil {
		return m.Gettime
	}
	return 0
}

func (m *MailInfo) GetHaveread() bool {
	if m != nil {
		return m.Haveread
	}
	return false
}

func (m *MailInfo) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *MailInfo) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *MailInfo) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *MailInfo) GetObjs() []*MailObject {
	if m != nil {
		return m.Objs
	}
	return nil
}

func (m *MailInfo) GetHaveget() bool {
	if m != nil {
		return m.Haveget
	}
	return false
}

func (m *MailInfo) GetButton() string {
	if m != nil {
		return m.Button
	}
	return ""
}

// 获取邮件列表
type ReqGetMailList struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReqGetMailList) Reset()         { *m = ReqGetMailList{} }
func (m *ReqGetMailList) String() string { return proto.CompactTextString(m) }
func (*ReqGetMailList) ProtoMessage()    {}
func (*ReqGetMailList) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{22}
}
func (m *ReqGetMailList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReqGetMailList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReqGetMailList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ReqGetMailList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqGetMailList.Merge(dst, src)
}
func (m *ReqGetMailList) XXX_Size() int {
	return m.Size()
}
func (m *ReqGetMailList) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqGetMailList.DiscardUnknown(m)
}

var xxx_messageInfo_ReqGetMailList proto.InternalMessageInfo

// 返回邮件列表
type RetMailList struct {
	Mails                []*MailInfo `protobuf:"bytes,1,rep,name=mails" json:"mails,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *RetMailList) Reset()         { *m = RetMailList{} }
func (m *RetMailList) String() string { return proto.CompactTextString(m) }
func (*RetMailList) ProtoMessage()    {}
func (*RetMailList) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{23}
}
func (m *RetMailList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetMailList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RetMailList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RetMailList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetMailList.Merge(dst, src)
}
func (m *RetMailList) XXX_Size() int {
	return m.Size()
}
func (m *RetMailList) XXX_DiscardUnknown() {
	xxx_messageInfo_RetMailList.DiscardUnknown(m)
}

var xxx_messageInfo_RetMailList proto.InternalMessageInfo

func (m *RetMailList) GetMails() []*MailInfo {
	if m != nil {
		return m.Mails
	}
	return nil
}

// 查看邮件
type ReqMailInfo struct {
	Mailid               uint64   `protobuf:"varint,1,opt,name=mailid" json:"mailid"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReqMailInfo) Reset()         { *m = ReqMailInfo{} }
func (m *ReqMailInfo) String() string { return proto.CompactTextString(m) }
func (*ReqMailInfo) ProtoMessage()    {}
func (*ReqMailInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{24}
}
func (m *ReqMailInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReqMailInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReqMailInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ReqMailInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqMailInfo.Merge(dst, src)
}
func (m *ReqMailInfo) XXX_Size() int {
	return m.Size()
}
func (m *ReqMailInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqMailInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ReqMailInfo proto.InternalMessageInfo

func (m *ReqMailInfo) GetMailid() uint64 {
	if m != nil {
		return m.Mailid
	}
	return 0
}

// 返回邮件信息
type RetMailInfo struct {
	Mail                 *MailInfo `protobuf:"bytes,1,opt,name=mail" json:"mail,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *RetMailInfo) Reset()         { *m = RetMailInfo{} }
func (m *RetMailInfo) String() string { return proto.CompactTextString(m) }
func (*RetMailInfo) ProtoMessage()    {}
func (*RetMailInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{25}
}
func (m *RetMailInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetMailInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RetMailInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RetMailInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetMailInfo.Merge(dst, src)
}
func (m *RetMailInfo) XXX_Size() int {
	return m.Size()
}
func (m *RetMailInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RetMailInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RetMailInfo proto.InternalMessageInfo

func (m *RetMailInfo) GetMail() *MailInfo {
	if m != nil {
		return m.Mail
	}
	return nil
}

// 公告信息
type AnnuonceInfo struct {
	Id                   uint64   `protobuf:"varint,1,opt,name=id" json:"id"`
	StartTime            int64    `protobuf:"varint,2,opt,name=startTime" json:"startTime"`
	EndTime              int64    `protobuf:"varint,3,opt,name=endTime" json:"endTime"`
	InternalTime         int64    `protobuf:"varint,4,opt,name=internalTime" json:"internalTime"`
	Content              string   `protobuf:"bytes,5,opt,name=content" json:"content"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AnnuonceInfo) Reset()         { *m = AnnuonceInfo{} }
func (m *AnnuonceInfo) String() string { return proto.CompactTextString(m) }
func (*AnnuonceInfo) ProtoMessage()    {}
func (*AnnuonceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{26}
}
func (m *AnnuonceInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnnuonceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnnuonceInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AnnuonceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnnuonceInfo.Merge(dst, src)
}
func (m *AnnuonceInfo) XXX_Size() int {
	return m.Size()
}
func (m *AnnuonceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AnnuonceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AnnuonceInfo proto.InternalMessageInfo

func (m *AnnuonceInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AnnuonceInfo) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *AnnuonceInfo) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *AnnuonceInfo) GetInternalTime() int64 {
	if m != nil {
		return m.InternalTime
	}
	return 0
}

func (m *AnnuonceInfo) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

// s-->c 初始化公告信息
type InitAnnuonceInfoRet struct {
	Item                 []*AnnuonceInfo `protobuf:"bytes,1,rep,name=item" json:"item,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *InitAnnuonceInfoRet) Reset()         { *m = InitAnnuonceInfoRet{} }
func (m *InitAnnuonceInfoRet) String() string { return proto.CompactTextString(m) }
func (*InitAnnuonceInfoRet) ProtoMessage()    {}
func (*InitAnnuonceInfoRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{27}
}
func (m *InitAnnuonceInfoRet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitAnnuonceInfoRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InitAnnuonceInfoRet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InitAnnuonceInfoRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitAnnuonceInfoRet.Merge(dst, src)
}
func (m *InitAnnuonceInfoRet) XXX_Size() int {
	return m.Size()
}
func (m *InitAnnuonceInfoRet) XXX_DiscardUnknown() {
	xxx_messageInfo_InitAnnuonceInfoRet.DiscardUnknown(m)
}

var xxx_messageInfo_InitAnnuonceInfoRet proto.InternalMessageInfo

func (m *InitAnnuonceInfoRet) GetItem() []*AnnuonceInfo {
	if m != nil {
		return m.Item
	}
	return nil
}

// 好友信息
type FriendInfo struct {
	Id                   uint64   `protobuf:"varint,1,opt,name=id" json:"id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name" json:"name"`
	State                uint32   `protobuf:"varint,3,opt,name=state" json:"state"`
	Time                 uint32   `protobuf:"varint,4,opt,name=time" json:"time"`
	Url                  string   `protobuf:"bytes,5,opt,name=url" json:"url"`
	Enterplat            string   `protobuf:"bytes,6,opt,name=enterplat" json:"enterplat"`
	Qqvip                uint32   `protobuf:"varint,7,opt,name=qqvip" json:"qqvip"`
	Nickname             string   `protobuf:"bytes,8,opt,name=nickname" json:"nickname"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FriendInfo) Reset()         { *m = FriendInfo{} }
func (m *FriendInfo) String() string { return proto.CompactTextString(m) }
func (*FriendInfo) ProtoMessage()    {}
func (*FriendInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{28}
}
func (m *FriendInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FriendInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FriendInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FriendInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FriendInfo.Merge(dst, src)
}
func (m *FriendInfo) XXX_Size() int {
	return m.Size()
}
func (m *FriendInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FriendInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FriendInfo proto.InternalMessageInfo

func (m *FriendInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *FriendInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FriendInfo) GetState() uint32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *FriendInfo) GetTime() uint32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *FriendInfo) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *FriendInfo) GetEnterplat() string {
	if m != nil {
		return m.Enterplat
	}
	return ""
}

func (m *FriendInfo) GetQqvip() uint32 {
	if m != nil {
		return m.Qqvip
	}
	return 0
}

func (m *FriendInfo) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

// c-->s 请求平台好友状态
type PlatFriendStateReq struct {
	Openid               []string `protobuf:"bytes,1,rep,name=openid" json:"openid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlatFriendStateReq) Reset()         { *m = PlatFriendStateReq{} }
func (m *PlatFriendStateReq) String() string { return proto.CompactTextString(m) }
func (*PlatFriendStateReq) ProtoMessage()    {}
func (*PlatFriendStateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{29}
}
func (m *PlatFriendStateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlatFriendStateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlatFriendStateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PlatFriendStateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlatFriendStateReq.Merge(dst, src)
}
func (m *PlatFriendStateReq) XXX_Size() int {
	return m.Size()
}
func (m *PlatFriendStateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PlatFriendStateReq.DiscardUnknown(m)
}

var xxx_messageInfo_PlatFriendStateReq proto.InternalMessageInfo

func (m *PlatFriendStateReq) GetOpenid() []string {
	if m != nil {
		return m.Openid
	}
	return nil
}

// 组队的队员的槽位信息
type LobboySceneMemberSlot struct {
	Uid                  uint64   `protobuf:"varint,1,opt,name=uid" json:"uid"`
	SlotIdx              uint32   `protobuf:"varint,2,opt,name=slotIdx" json:"slotIdx"`
	RoleModel            string   `protobuf:"bytes,3,opt,name=roleModel" json:"roleModel"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LobboySceneMemberSlot) Reset()         { *m = LobboySceneMemberSlot{} }
func (m *LobboySceneMemberSlot) String() string { return proto.CompactTextString(m) }
func (*LobboySceneMemberSlot) ProtoMessage()    {}
func (*LobboySceneMemberSlot) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{30}
}
func (m *LobboySceneMemberSlot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LobboySceneMemberSlot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LobboySceneMemberSlot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LobboySceneMemberSlot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LobboySceneMemberSlot.Merge(dst, src)
}
func (m *LobboySceneMemberSlot) XXX_Size() int {
	return m.Size()
}
func (m *LobboySceneMemberSlot) XXX_DiscardUnknown() {
	xxx_messageInfo_LobboySceneMemberSlot.DiscardUnknown(m)
}

var xxx_messageInfo_LobboySceneMemberSlot proto.InternalMessageInfo

func (m *LobboySceneMemberSlot) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *LobboySceneMemberSlot) GetSlotIdx() uint32 {
	if m != nil {
		return m.SlotIdx
	}
	return 0
}

func (m *LobboySceneMemberSlot) GetRoleModel() string {
	if m != nil {
		return m.RoleModel
	}
	return ""
}

// 同步队员槽位信息
type SyncLobboySceneMembersSlotsInfo struct {
	Id                   uint64                   `protobuf:"varint,1,opt,name=id" json:"id"`
	SoltList             []*LobboySceneMemberSlot `protobuf:"bytes,2,rep,name=soltList" json:"soltList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *SyncLobboySceneMembersSlotsInfo) Reset()         { *m = SyncLobboySceneMembersSlotsInfo{} }
func (m *SyncLobboySceneMembersSlotsInfo) String() string { return proto.CompactTextString(m) }
func (*SyncLobboySceneMembersSlotsInfo) ProtoMessage()    {}
func (*SyncLobboySceneMembersSlotsInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{31}
}
func (m *SyncLobboySceneMembersSlotsInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncLobboySceneMembersSlotsInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncLobboySceneMembersSlotsInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SyncLobboySceneMembersSlotsInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncLobboySceneMembersSlotsInfo.Merge(dst, src)
}
func (m *SyncLobboySceneMembersSlotsInfo) XXX_Size() int {
	return m.Size()
}
func (m *SyncLobboySceneMembersSlotsInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncLobboySceneMembersSlotsInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SyncLobboySceneMembersSlotsInfo proto.InternalMessageInfo

func (m *SyncLobboySceneMembersSlotsInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SyncLobboySceneMembersSlotsInfo) GetSoltList() []*LobboySceneMemberSlot {
	if m != nil {
		return m.SoltList
	}
	return nil
}

// 请求交换大厅槽位
type ReqChangeLobboySceneMemberSlot struct {
	SlotIdx              uint32   `protobuf:"varint,1,opt,name=slotIdx" json:"slotIdx"`
	TeamID               uint64   `protobuf:"varint,2,opt,name=teamID" json:"teamID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReqChangeLobboySceneMemberSlot) Reset()         { *m = ReqChangeLobboySceneMemberSlot{} }
func (m *ReqChangeLobboySceneMemberSlot) String() string { return proto.CompactTextString(m) }
func (*ReqChangeLobboySceneMemberSlot) ProtoMessage()    {}
func (*ReqChangeLobboySceneMemberSlot) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_c597653b54925f1b, []int{32}
}
func (m *ReqChangeLobboySceneMemberSlot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReqChangeLobboySceneMemberSlot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReqChangeLobboySceneMemberSlot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ReqChangeLobboySceneMemberSlot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqChangeLobboySceneMemberSlot.Merge(dst, src)
}
func (m *ReqChangeLobboySceneMemberSlot) XXX_Size() int {
	return m.Size()
}
func (m *ReqChangeLobboySceneMemberSlot) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqChangeLobboySceneMemberSlot.DiscardUnknown(m)
}

var xxx_messageInfo_ReqChangeLobboySceneMemberSlot proto.InternalMessageInfo

func (m *ReqChangeLobboySceneMemberSlot) GetSlotIdx() uint32 {
	if m != nil {
		return m.SlotIdx
	}
	return 0
}

func (m *ReqChangeLobboySceneMemberSlot) GetTeamID() uint64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func init() {
	proto.RegisterType((*UserMainDataNotify)(nil), "protoMsg.UserMainDataNotify")
	proto.RegisterType((*Vector3)(nil), "protoMsg.Vector3")
	proto.RegisterType((*T_Object)(nil), "protoMsg.T_Object")
	proto.RegisterType((*ChracterMapDataInfo)(nil), "protoMsg.ChracterMapDataInfo")
	proto.RegisterType((*ChatNotify)(nil), "protoMsg.ChatNotify")
	proto.RegisterType((*ZoneNotify)(nil), "protoMsg.ZoneNotify")
	proto.RegisterType((*ChangeBulletReq)(nil), "protoMsg.ChangeBulletReq")
	proto.RegisterType((*ChangeBulletRet)(nil), "protoMsg.ChangeBulletRet")
	proto.RegisterType((*TeamMemberInfo)(nil), "protoMsg.TeamMemberInfo")
	proto.RegisterType((*SyncTeamInfoRet)(nil), "protoMsg.SyncTeamInfoRet")
	proto.RegisterType((*SyncRoomTeamPlayerItem)(nil), "protoMsg.SyncRoomTeamPlayerItem")
	proto.RegisterType((*SymcRoomTeamInfoRet)(nil), "protoMsg.SymcRoomTeamInfoRet")
	proto.RegisterType((*ItemProp)(nil), "protoMsg.ItemProp")
	proto.RegisterType((*RefreshBoxObjNotify)(nil), "protoMsg.RefreshBoxObjNotify")
	proto.RegisterType((*HeadProp)(nil), "protoMsg.HeadProp")
	proto.RegisterType((*BodyProp)(nil), "protoMsg.BodyProp")
	proto.RegisterType((*BackPackProp)(nil), "protoMsg.BackPackProp")
	proto.RegisterType((*PlayerRegister)(nil), "protoMsg.PlayerRegister")
	proto.RegisterType((*PlayerLogin)(nil), "protoMsg.PlayerLogin")
	proto.RegisterType((*PlayerLogout)(nil), "protoMsg.PlayerLogout")
	proto.RegisterType((*MailObject)(nil), "protoMsg.MailObject")
	proto.RegisterType((*MailInfo)(nil), "protoMsg.MailInfo")
	proto.RegisterType((*ReqGetMailList)(nil), "protoMsg.ReqGetMailList")
	proto.RegisterType((*RetMailList)(nil), "protoMsg.RetMailList")
	proto.RegisterType((*ReqMailInfo)(nil), "protoMsg.ReqMailInfo")
	proto.RegisterType((*RetMailInfo)(nil), "protoMsg.RetMailInfo")
	proto.RegisterType((*AnnuonceInfo)(nil), "protoMsg.AnnuonceInfo")
	proto.RegisterType((*InitAnnuonceInfoRet)(nil), "protoMsg.InitAnnuonceInfoRet")
	proto.RegisterType((*FriendInfo)(nil), "protoMsg.FriendInfo")
	proto.RegisterType((*PlatFriendStateReq)(nil), "protoMsg.PlatFriendStateReq")
	proto.RegisterType((*LobboySceneMemberSlot)(nil), "protoMsg.LobboySceneMemberSlot")
	proto.RegisterType((*SyncLobboySceneMembersSlotsInfo)(nil), "protoMsg.SyncLobboySceneMembersSlotsInfo")
	proto.RegisterType((*ReqChangeLobboySceneMemberSlot)(nil), "protoMsg.ReqChangeLobboySceneMemberSlot")
}
func (m *UserMainDataNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserMainDataNotify) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Uid))
	dAtA[i] = 0x12
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x18
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Coins))
	dAtA[i] = 0x20
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Diams))
	return i, nil
}

func (m *Vector3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vector3) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.X))))
	i += 4
	dAtA[i] = 0x15
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Y))))
	i += 4
	dAtA[i] = 0x1d
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Z))))
	i += 4
	return i, nil
}

func (m *T_Object) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *T_Object) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Baseid))
	dAtA[i] = 0x10
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Thisid))
	dAtA[i] = 0x18
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Count))
	if len(m.Gunreform) > 0 {
		for _, num := range m.Gunreform {
			dAtA[i] = 0x20
			i++
			i = encodeVarintGame(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x28
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Bullet))
	dAtA[i] = 0x30
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Reducedam))
	return i, nil
}

func (m *ChracterMapDataInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChracterMapDataInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Uid))
	dAtA[i] = 0x12
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x18
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Level))
	if m.Pos != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Pos.Size()))
		n1, err := m.Pos.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	dAtA[i] = 0x2d
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Mvspeed))))
	i += 4
	dAtA[i] = 0x30
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Maxhp))
	dAtA[i] = 0x38
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Hp))
	dAtA[i] = 0x45
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Orientation))))
	i += 4
	if m.Weapon != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Weapon.Size()))
		n2, err := m.Weapon.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Secweapon != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Secweapon.Size()))
		n3, err := m.Secweapon.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Armors) > 0 {
		for _, num := range m.Armors {
			dAtA[i] = 0x58
			i++
			i = encodeVarintGame(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *ChatNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatNotify) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.Content)))
	i += copy(dAtA[i:], m.Content)
	dAtA[i] = 0x10
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Type))
	return i, nil
}

func (m *ZoneNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZoneNotify) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Type))
	if m.Center != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Center.Size()))
		n4, err := m.Center.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	dAtA[i] = 0x1d
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Radius))))
	i += 4
	dAtA[i] = 0x20
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Interval))
	return i, nil
}

func (m *ChangeBulletReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeBulletReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.Full {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x10
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Pos))
	return i, nil
}

func (m *ChangeBulletRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeBulletRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Uid))
	dAtA[i] = 0x10
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Bullet))
	return i, nil
}

func (m *TeamMemberInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TeamMemberInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Uid))
	dAtA[i] = 0x12
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x18
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.MemState))
	dAtA[i] = 0x20
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Modelid))
	dAtA[i] = 0x28
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Intotime))
	dAtA[i] = 0x30
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Slot))
	return i, nil
}

func (m *SyncTeamInfoRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncTeamInfoRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Id))
	dAtA[i] = 0x10
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.TeamState))
	if len(m.Memberinfo) > 0 {
		for _, msg := range m.Memberinfo {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Leaderid))
	dAtA[i] = 0x28
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Teamtype))
	dAtA[i] = 0x30
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Automatch))
	dAtA[i] = 0x38
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Mapid))
	return i, nil
}

func (m *SyncRoomTeamPlayerItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncRoomTeamPlayerItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Id))
	dAtA[i] = 0x10
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Hp))
	if m.Pos != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Pos.Size()))
		n5, err := m.Pos.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.State))
	if m.Rota != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Rota.Size()))
		n6, err := m.Rota.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *SymcRoomTeamInfoRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SymcRoomTeamInfoRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Item) > 0 {
		for _, msg := range m.Item {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ItemProp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemProp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Baseid))
	dAtA[i] = 0x10
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Id))
	dAtA[i] = 0x18
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Num))
	return i, nil
}

func (m *RefreshBoxObjNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshBoxObjNotify) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Id))
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HeadProp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeadProp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Baseid))
	dAtA[i] = 0x10
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Reducedam))
	dAtA[i] = 0x18
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Maxreduce))
	return i, nil
}

func (m *BodyProp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BodyProp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Baseid))
	dAtA[i] = 0x10
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Reducedam))
	dAtA[i] = 0x18
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Maxreduce))
	return i, nil
}

func (m *BackPackProp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackPackProp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Baseid))
	return i, nil
}

func (m *PlayerRegister) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerRegister) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.GameSvrID)))
	i += copy(dAtA[i:], m.GameSvrID)
	dAtA[i] = 0x12
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.DtEventTime)))
	i += copy(dAtA[i:], m.DtEventTime)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.VGameAppID)))
	i += copy(dAtA[i:], m.VGameAppID)
	dAtA[i] = 0x20
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.PlatID))
	dAtA[i] = 0x28
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.IZoneAreaID))
	dAtA[i] = 0x32
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.VOpenID)))
	i += copy(dAtA[i:], m.VOpenID)
	dAtA[i] = 0x3a
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.TelecomOper)))
	i += copy(dAtA[i:], m.TelecomOper)
	dAtA[i] = 0x42
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.RegChannel)))
	i += copy(dAtA[i:], m.RegChannel)
	dAtA[i] = 0x48
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.LoginChannel))
	return i, nil
}

func (m *PlayerLogin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerLogin) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.GameSvrID)))
	i += copy(dAtA[i:], m.GameSvrID)
	dAtA[i] = 0x12
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.DtEventTime)))
	i += copy(dAtA[i:], m.DtEventTime)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.VGameAppID)))
	i += copy(dAtA[i:], m.VGameAppID)
	dAtA[i] = 0x20
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.PlatID))
	dAtA[i] = 0x28
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.IZoneAreaID))
	dAtA[i] = 0x32
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.VOpenID)))
	i += copy(dAtA[i:], m.VOpenID)
	dAtA[i] = 0x38
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Level))
	dAtA[i] = 0x40
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.PlayerFriendsNum))
	dAtA[i] = 0x4a
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.ClientVersion)))
	i += copy(dAtA[i:], m.ClientVersion)
	dAtA[i] = 0x52
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.SystemHardware)))
	i += copy(dAtA[i:], m.SystemHardware)
	dAtA[i] = 0x5a
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.TelecomOper)))
	i += copy(dAtA[i:], m.TelecomOper)
	dAtA[i] = 0x62
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.Network)))
	i += copy(dAtA[i:], m.Network)
	dAtA[i] = 0x68
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.LoginChannel))
	dAtA[i] = 0x72
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.VRoleID)))
	i += copy(dAtA[i:], m.VRoleID)
	dAtA[i] = 0x7a
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.VRoleName)))
	i += copy(dAtA[i:], m.VRoleName)
	dAtA[i] = 0x82
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.RegChannel)))
	i += copy(dAtA[i:], m.RegChannel)
	return i, nil
}

func (m *PlayerLogout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerLogout) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.GameSvrID)))
	i += copy(dAtA[i:], m.GameSvrID)
	dAtA[i] = 0x12
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.DtEventTime)))
	i += copy(dAtA[i:], m.DtEventTime)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.VGameAppID)))
	i += copy(dAtA[i:], m.VGameAppID)
	dAtA[i] = 0x20
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.PlatID))
	dAtA[i] = 0x28
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.IZoneAreaID))
	dAtA[i] = 0x32
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.VOpenID)))
	i += copy(dAtA[i:], m.VOpenID)
	dAtA[i] = 0x38
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.OnlineTime))
	dAtA[i] = 0x40
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Level))
	dAtA[i] = 0x48
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.PlayerFriendsNum))
	dAtA[i] = 0x52
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.ClientVersion)))
	i += copy(dAtA[i:], m.ClientVersion)
	dAtA[i] = 0x5a
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.SystemHardware)))
	i += copy(dAtA[i:], m.SystemHardware)
	dAtA[i] = 0x62
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.TelecomOper)))
	i += copy(dAtA[i:], m.TelecomOper)
	dAtA[i] = 0x6a
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.Network)))
	i += copy(dAtA[i:], m.Network)
	return i, nil
}

func (m *MailObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailObject) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Id))
	dAtA[i] = 0x10
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Num))
	return i, nil
}

func (m *MailInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Mailid))
	dAtA[i] = 0x10
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Mailtype))
	dAtA[i] = 0x18
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Gettime))
	dAtA[i] = 0x20
	i++
	if m.Haveread {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x2a
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.Title)))
	i += copy(dAtA[i:], m.Title)
	dAtA[i] = 0x32
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.Text)))
	i += copy(dAtA[i:], m.Text)
	dAtA[i] = 0x3a
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.Url)))
	i += copy(dAtA[i:], m.Url)
	if len(m.Objs) > 0 {
		for _, msg := range m.Objs {
			dAtA[i] = 0x42
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x48
	i++
	if m.Haveget {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x52
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.Button)))
	i += copy(dAtA[i:], m.Button)
	return i, nil
}

func (m *ReqGetMailList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetMailList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RetMailList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetMailList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mails) > 0 {
		for _, msg := range m.Mails {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReqMailInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqMailInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Mailid))
	return i, nil
}

func (m *RetMailInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetMailInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mail != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Mail.Size()))
		n7, err := m.Mail.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *AnnuonceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnnuonceInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Id))
	dAtA[i] = 0x10
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.StartTime))
	dAtA[i] = 0x18
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.EndTime))
	dAtA[i] = 0x20
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.InternalTime))
	dAtA[i] = 0x2a
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.Content)))
	i += copy(dAtA[i:], m.Content)
	return i, nil
}

func (m *InitAnnuonceInfoRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitAnnuonceInfoRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Item) > 0 {
		for _, msg := range m.Item {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FriendInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FriendInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Id))
	dAtA[i] = 0x12
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x18
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.State))
	dAtA[i] = 0x20
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Time))
	dAtA[i] = 0x2a
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.Url)))
	i += copy(dAtA[i:], m.Url)
	dAtA[i] = 0x32
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.Enterplat)))
	i += copy(dAtA[i:], m.Enterplat)
	dAtA[i] = 0x38
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Qqvip))
	dAtA[i] = 0x42
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.Nickname)))
	i += copy(dAtA[i:], m.Nickname)
	return i, nil
}

func (m *PlatFriendStateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlatFriendStateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Openid) > 0 {
		for _, s := range m.Openid {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *LobboySceneMemberSlot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LobboySceneMemberSlot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Uid))
	dAtA[i] = 0x10
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.SlotIdx))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintGame(dAtA, i, uint64(len(m.RoleModel)))
	i += copy(dAtA[i:], m.RoleModel)
	return i, nil
}

func (m *SyncLobboySceneMembersSlotsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncLobboySceneMembersSlotsInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.Id))
	if len(m.SoltList) > 0 {
		for _, msg := range m.SoltList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReqChangeLobboySceneMemberSlot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqChangeLobboySceneMemberSlot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.SlotIdx))
	dAtA[i] = 0x10
	i++
	i = encodeVarintGame(dAtA, i, uint64(m.TeamID))
	return i, nil
}

func encodeVarintGame(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *UserMainDataNotify) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGame(uint64(m.Uid))
	l = len(m.Name)
	n += 1 + l + sovGame(uint64(l))
	n += 1 + sovGame(uint64(m.Coins))
	n += 1 + sovGame(uint64(m.Diams))
	return n
}

func (m *Vector3) Size() (n int) {
	var l int
	_ = l
	n += 5
	n += 5
	n += 5
	return n
}

func (m *T_Object) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGame(uint64(m.Baseid))
	n += 1 + sovGame(uint64(m.Thisid))
	n += 1 + sovGame(uint64(m.Count))
	if len(m.Gunreform) > 0 {
		for _, e := range m.Gunreform {
			n += 1 + sovGame(uint64(e))
		}
	}
	n += 1 + sovGame(uint64(m.Bullet))
	n += 1 + sovGame(uint64(m.Reducedam))
	return n
}

func (m *ChracterMapDataInfo) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGame(uint64(m.Uid))
	l = len(m.Name)
	n += 1 + l + sovGame(uint64(l))
	n += 1 + sovGame(uint64(m.Level))
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	n += 5
	n += 1 + sovGame(uint64(m.Maxhp))
	n += 1 + sovGame(uint64(m.Hp))
	n += 5
	if m.Weapon != nil {
		l = m.Weapon.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	if m.Secweapon != nil {
		l = m.Secweapon.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	if len(m.Armors) > 0 {
		for _, e := range m.Armors {
			n += 1 + sovGame(uint64(e))
		}
	}
	return n
}

func (m *ChatNotify) Size() (n int) {
	var l int
	_ = l
	l = len(m.Content)
	n += 1 + l + sovGame(uint64(l))
	n += 1 + sovGame(uint64(m.Type))
	return n
}

func (m *ZoneNotify) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGame(uint64(m.Type))
	if m.Center != nil {
		l = m.Center.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	n += 5
	n += 1 + sovGame(uint64(m.Interval))
	return n
}

func (m *ChangeBulletReq) Size() (n int) {
	var l int
	_ = l
	n += 2
	n += 1 + sovGame(uint64(m.Pos))
	return n
}

func (m *ChangeBulletRet) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGame(uint64(m.Uid))
	n += 1 + sovGame(uint64(m.Bullet))
	return n
}

func (m *TeamMemberInfo) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGame(uint64(m.Uid))
	l = len(m.Name)
	n += 1 + l + sovGame(uint64(l))
	n += 1 + sovGame(uint64(m.MemState))
	n += 1 + sovGame(uint64(m.Modelid))
	n += 1 + sovGame(uint64(m.Intotime))
	n += 1 + sovGame(uint64(m.Slot))
	return n
}

func (m *SyncTeamInfoRet) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGame(uint64(m.Id))
	n += 1 + sovGame(uint64(m.TeamState))
	if len(m.Memberinfo) > 0 {
		for _, e := range m.Memberinfo {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	n += 1 + sovGame(uint64(m.Leaderid))
	n += 1 + sovGame(uint64(m.Teamtype))
	n += 1 + sovGame(uint64(m.Automatch))
	n += 1 + sovGame(uint64(m.Mapid))
	return n
}

func (m *SyncRoomTeamPlayerItem) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGame(uint64(m.Id))
	n += 1 + sovGame(uint64(m.Hp))
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	n += 1 + sovGame(uint64(m.State))
	if m.Rota != nil {
		l = m.Rota.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *SymcRoomTeamInfoRet) Size() (n int) {
	var l int
	_ = l
	if len(m.Item) > 0 {
		for _, e := range m.Item {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	return n
}

func (m *ItemProp) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGame(uint64(m.Baseid))
	n += 1 + sovGame(uint64(m.Id))
	n += 1 + sovGame(uint64(m.Num))
	return n
}

func (m *RefreshBoxObjNotify) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGame(uint64(m.Id))
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	return n
}

func (m *HeadProp) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGame(uint64(m.Baseid))
	n += 1 + sovGame(uint64(m.Reducedam))
	n += 1 + sovGame(uint64(m.Maxreduce))
	return n
}

func (m *BodyProp) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGame(uint64(m.Baseid))
	n += 1 + sovGame(uint64(m.Reducedam))
	n += 1 + sovGame(uint64(m.Maxreduce))
	return n
}

func (m *BackPackProp) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGame(uint64(m.Baseid))
	return n
}

func (m *PlayerRegister) Size() (n int) {
	var l int
	_ = l
	l = len(m.GameSvrID)
	n += 1 + l + sovGame(uint64(l))
	l = len(m.DtEventTime)
	n += 1 + l + sovGame(uint64(l))
	l = len(m.VGameAppID)
	n += 1 + l + sovGame(uint64(l))
	n += 1 + sovGame(uint64(m.PlatID))
	n += 1 + sovGame(uint64(m.IZoneAreaID))
	l = len(m.VOpenID)
	n += 1 + l + sovGame(uint64(l))
	l = len(m.TelecomOper)
	n += 1 + l + sovGame(uint64(l))
	l = len(m.RegChannel)
	n += 1 + l + sovGame(uint64(l))
	n += 1 + sovGame(uint64(m.LoginChannel))
	return n
}

func (m *PlayerLogin) Size() (n int) {
	var l int
	_ = l
	l = len(m.GameSvrID)
	n += 1 + l + sovGame(uint64(l))
	l = len(m.DtEventTime)
	n += 1 + l + sovGame(uint64(l))
	l = len(m.VGameAppID)
	n += 1 + l + sovGame(uint64(l))
	n += 1 + sovGame(uint64(m.PlatID))
	n += 1 + sovGame(uint64(m.IZoneAreaID))
	l = len(m.VOpenID)
	n += 1 + l + sovGame(uint64(l))
	n += 1 + sovGame(uint64(m.Level))
	n += 1 + sovGame(uint64(m.PlayerFriendsNum))
	l = len(m.ClientVersion)
	n += 1 + l + sovGame(uint64(l))
	l = len(m.SystemHardware)
	n += 1 + l + sovGame(uint64(l))
	l = len(m.TelecomOper)
	n += 1 + l + sovGame(uint64(l))
	l = len(m.Network)
	n += 1 + l + sovGame(uint64(l))
	n += 1 + sovGame(uint64(m.LoginChannel))
	l = len(m.VRoleID)
	n += 1 + l + sovGame(uint64(l))
	l = len(m.VRoleName)
	n += 1 + l + sovGame(uint64(l))
	l = len(m.RegChannel)
	n += 2 + l + sovGame(uint64(l))
	return n
}

func (m *PlayerLogout) Size() (n int) {
	var l int
	_ = l
	l = len(m.GameSvrID)
	n += 1 + l + sovGame(uint64(l))
	l = len(m.DtEventTime)
	n += 1 + l + sovGame(uint64(l))
	l = len(m.VGameAppID)
	n += 1 + l + sovGame(uint64(l))
	n += 1 + sovGame(uint64(m.PlatID))
	n += 1 + sovGame(uint64(m.IZoneAreaID))
	l = len(m.VOpenID)
	n += 1 + l + sovGame(uint64(l))
	n += 1 + sovGame(uint64(m.OnlineTime))
	n += 1 + sovGame(uint64(m.Level))
	n += 1 + sovGame(uint64(m.PlayerFriendsNum))
	l = len(m.ClientVersion)
	n += 1 + l + sovGame(uint64(l))
	l = len(m.SystemHardware)
	n += 1 + l + sovGame(uint64(l))
	l = len(m.TelecomOper)
	n += 1 + l + sovGame(uint64(l))
	l = len(m.Network)
	n += 1 + l + sovGame(uint64(l))
	return n
}

func (m *MailObject) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGame(uint64(m.Id))
	n += 1 + sovGame(uint64(m.Num))
	return n
}

func (m *MailInfo) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGame(uint64(m.Mailid))
	n += 1 + sovGame(uint64(m.Mailtype))
	n += 1 + sovGame(uint64(m.Gettime))
	n += 2
	l = len(m.Title)
	n += 1 + l + sovGame(uint64(l))
	l = len(m.Text)
	n += 1 + l + sovGame(uint64(l))
	l = len(m.Url)
	n += 1 + l + sovGame(uint64(l))
	if len(m.Objs) > 0 {
		for _, e := range m.Objs {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	n += 2
	l = len(m.Button)
	n += 1 + l + sovGame(uint64(l))
	return n
}

func (m *ReqGetMailList) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RetMailList) Size() (n int) {
	var l int
	_ = l
	if len(m.Mails) > 0 {
		for _, e := range m.Mails {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	return n
}

func (m *ReqMailInfo) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGame(uint64(m.Mailid))
	return n
}

func (m *RetMailInfo) Size() (n int) {
	var l int
	_ = l
	if m.Mail != nil {
		l = m.Mail.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *AnnuonceInfo) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGame(uint64(m.Id))
	n += 1 + sovGame(uint64(m.StartTime))
	n += 1 + sovGame(uint64(m.EndTime))
	n += 1 + sovGame(uint64(m.InternalTime))
	l = len(m.Content)
	n += 1 + l + sovGame(uint64(l))
	return n
}

func (m *InitAnnuonceInfoRet) Size() (n int) {
	var l int
	_ = l
	if len(m.Item) > 0 {
		for _, e := range m.Item {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	return n
}

func (m *FriendInfo) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGame(uint64(m.Id))
	l = len(m.Name)
	n += 1 + l + sovGame(uint64(l))
	n += 1 + sovGame(uint64(m.State))
	n += 1 + sovGame(uint64(m.Time))
	l = len(m.Url)
	n += 1 + l + sovGame(uint64(l))
	l = len(m.Enterplat)
	n += 1 + l + sovGame(uint64(l))
	n += 1 + sovGame(uint64(m.Qqvip))
	l = len(m.Nickname)
	n += 1 + l + sovGame(uint64(l))
	return n
}

func (m *PlatFriendStateReq) Size() (n int) {
	var l int
	_ = l
	if len(m.Openid) > 0 {
		for _, s := range m.Openid {
			l = len(s)
			n += 1 + l + sovGame(uint64(l))
		}
	}
	return n
}

func (m *LobboySceneMemberSlot) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGame(uint64(m.Uid))
	n += 1 + sovGame(uint64(m.SlotIdx))
	l = len(m.RoleModel)
	n += 1 + l + sovGame(uint64(l))
	return n
}

func (m *SyncLobboySceneMembersSlotsInfo) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGame(uint64(m.Id))
	if len(m.SoltList) > 0 {
		for _, e := range m.SoltList {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	return n
}

func (m *ReqChangeLobboySceneMemberSlot) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGame(uint64(m.SlotIdx))
	n += 1 + sovGame(uint64(m.TeamID))
	return n
}

func sovGame(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGame(x uint64) (n int) {
	return sovGame(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UserMainDataNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserMainDataNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserMainDataNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coins", wireType)
			}
			m.Coins = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coins |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diams", wireType)
			}
			m.Diams = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Diams |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vector3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vector3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vector3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.X = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Y = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Z = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *T_Object) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: T_Object: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: T_Object: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Baseid", wireType)
			}
			m.Baseid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Baseid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thisid", wireType)
			}
			m.Thisid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Thisid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Gunreform = append(m.Gunreform, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGame
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGame
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Gunreform = append(m.Gunreform, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Gunreform", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bullet", wireType)
			}
			m.Bullet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bullet |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reducedam", wireType)
			}
			m.Reducedam = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reducedam |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChracterMapDataInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChracterMapDataInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChracterMapDataInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Vector3{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mvspeed", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Mvspeed = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maxhp", wireType)
			}
			m.Maxhp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Maxhp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			m.Hp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orientation", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Orientation = float32(math.Float32frombits(v))
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weapon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Weapon == nil {
				m.Weapon = &T_Object{}
			}
			if err := m.Weapon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secweapon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Secweapon == nil {
				m.Secweapon = &T_Object{}
			}
			if err := m.Secweapon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Armors = append(m.Armors, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGame
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGame
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Armors = append(m.Armors, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Armors", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZoneNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZoneNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZoneNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Center", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Center == nil {
				m.Center = &Vector3{}
			}
			if err := m.Center.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Radius = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeBulletReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeBulletReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeBulletReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Full", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Full = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeBulletRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeBulletRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeBulletRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bullet", wireType)
			}
			m.Bullet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bullet |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TeamMemberInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TeamMemberInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TeamMemberInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemState", wireType)
			}
			m.MemState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemState |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modelid", wireType)
			}
			m.Modelid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Modelid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intotime", wireType)
			}
			m.Intotime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Intotime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncTeamInfoRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncTeamInfoRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncTeamInfoRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamState", wireType)
			}
			m.TeamState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamState |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memberinfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memberinfo = append(m.Memberinfo, &TeamMemberInfo{})
			if err := m.Memberinfo[len(m.Memberinfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leaderid", wireType)
			}
			m.Leaderid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leaderid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Teamtype", wireType)
			}
			m.Teamtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Teamtype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Automatch", wireType)
			}
			m.Automatch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Automatch |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mapid", wireType)
			}
			m.Mapid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mapid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncRoomTeamPlayerItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncRoomTeamPlayerItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncRoomTeamPlayerItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			m.Hp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Vector3{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rota", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rota == nil {
				m.Rota = &Vector3{}
			}
			if err := m.Rota.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SymcRoomTeamInfoRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SymcRoomTeamInfoRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SymcRoomTeamInfoRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Item = append(m.Item, &SyncRoomTeamPlayerItem{})
			if err := m.Item[len(m.Item)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemProp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemProp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemProp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Baseid", wireType)
			}
			m.Baseid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Baseid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshBoxObjNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshBoxObjNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshBoxObjNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &ItemProp{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeadProp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeadProp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeadProp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Baseid", wireType)
			}
			m.Baseid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Baseid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reducedam", wireType)
			}
			m.Reducedam = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reducedam |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maxreduce", wireType)
			}
			m.Maxreduce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Maxreduce |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BodyProp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BodyProp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BodyProp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Baseid", wireType)
			}
			m.Baseid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Baseid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reducedam", wireType)
			}
			m.Reducedam = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reducedam |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maxreduce", wireType)
			}
			m.Maxreduce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Maxreduce |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackPackProp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackPackProp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackPackProp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Baseid", wireType)
			}
			m.Baseid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Baseid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerRegister) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerRegister: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerRegister: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameSvrID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameSvrID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtEventTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DtEventTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VGameAppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VGameAppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatID", wireType)
			}
			m.PlatID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlatID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IZoneAreaID", wireType)
			}
			m.IZoneAreaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IZoneAreaID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VOpenID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VOpenID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TelecomOper", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TelecomOper = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginChannel", wireType)
			}
			m.LoginChannel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoginChannel |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerLogin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerLogin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerLogin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameSvrID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameSvrID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtEventTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DtEventTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VGameAppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VGameAppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatID", wireType)
			}
			m.PlatID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlatID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IZoneAreaID", wireType)
			}
			m.IZoneAreaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IZoneAreaID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VOpenID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VOpenID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerFriendsNum", wireType)
			}
			m.PlayerFriendsNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerFriendsNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemHardware", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemHardware = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TelecomOper", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TelecomOper = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginChannel", wireType)
			}
			m.LoginChannel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoginChannel |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VRoleID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VRoleID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VRoleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VRoleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerLogout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerLogout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerLogout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameSvrID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameSvrID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtEventTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DtEventTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VGameAppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VGameAppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatID", wireType)
			}
			m.PlatID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlatID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IZoneAreaID", wireType)
			}
			m.IZoneAreaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IZoneAreaID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VOpenID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VOpenID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlineTime", wireType)
			}
			m.OnlineTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnlineTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerFriendsNum", wireType)
			}
			m.PlayerFriendsNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerFriendsNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemHardware", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemHardware = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TelecomOper", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TelecomOper = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mailid", wireType)
			}
			m.Mailid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mailid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mailtype", wireType)
			}
			m.Mailtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mailtype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gettime", wireType)
			}
			m.Gettime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gettime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Haveread", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Haveread = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objs = append(m.Objs, &MailObject{})
			if err := m.Objs[len(m.Objs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Haveget", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Haveget = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Button", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Button = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetMailList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetMailList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetMailList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetMailList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetMailList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetMailList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mails = append(m.Mails, &MailInfo{})
			if err := m.Mails[len(m.Mails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqMailInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqMailInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqMailInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mailid", wireType)
			}
			m.Mailid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mailid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetMailInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetMailInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetMailInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mail == nil {
				m.Mail = &MailInfo{}
			}
			if err := m.Mail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnnuonceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnnuonceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnnuonceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalTime", wireType)
			}
			m.InternalTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InternalTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitAnnuonceInfoRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitAnnuonceInfoRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitAnnuonceInfoRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Item = append(m.Item, &AnnuonceInfo{})
			if err := m.Item[len(m.Item)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FriendInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FriendInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FriendInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enterplat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enterplat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qqvip", wireType)
			}
			m.Qqvip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qqvip |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlatFriendStateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlatFriendStateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlatFriendStateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Openid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Openid = append(m.Openid, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LobboySceneMemberSlot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LobboySceneMemberSlot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LobboySceneMemberSlot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotIdx", wireType)
			}
			m.SlotIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlotIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncLobboySceneMembersSlotsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncLobboySceneMembersSlotsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncLobboySceneMembersSlotsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoltList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SoltList = append(m.SoltList, &LobboySceneMemberSlot{})
			if err := m.SoltList[len(m.SoltList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqChangeLobboySceneMemberSlot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqChangeLobboySceneMemberSlot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqChangeLobboySceneMemberSlot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotIdx", wireType)
			}
			m.SlotIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlotIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGame(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGame
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGame
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGame
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGame
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGame
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGame(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGame = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGame   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("game.proto", fileDescriptor_game_c597653b54925f1b) }

var fileDescriptor_game_c597653b54925f1b = []byte{
	// 1702 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0x4f, 0x6f, 0xdb, 0xd8,
	0x11, 0x5f, 0x52, 0xb2, 0x2c, 0x8d, 0x6c, 0x27, 0x65, 0x52, 0x83, 0x08, 0x02, 0xc5, 0x78, 0xdd,
	0x06, 0x6a, 0x1a, 0x04, 0x8b, 0x6d, 0x8b, 0x16, 0xed, 0x29, 0xb6, 0x76, 0xb3, 0x42, 0xe3, 0x38,
	0xa0, 0x5c, 0x1f, 0x7a, 0x68, 0xf1, 0x2c, 0x8e, 0x25, 0x26, 0xe4, 0x7b, 0x34, 0xf9, 0xe4, 0x58,
	0x7b, 0xe8, 0xbd, 0xb7, 0xf6, 0x7b, 0xf4, 0xd4, 0x4f, 0x50, 0xec, 0x69, 0x8f, 0xfd, 0x04, 0xc5,
	0x22, 0x3d, 0x15, 0xe8, 0x07, 0xe8, 0xa1, 0x87, 0x62, 0x86, 0xff, 0x65, 0xd9, 0xeb, 0xdd, 0x43,
	0x0f, 0x7b, 0x08, 0x62, 0xfe, 0x66, 0xc8, 0xf9, 0xf7, 0x7b, 0xf3, 0x66, 0x04, 0x30, 0x93, 0x11,
	0x3e, 0x8b, 0x13, 0x6d, 0xb4, 0xd3, 0xe5, 0xff, 0x0e, 0xd3, 0x99, 0xf8, 0x03, 0x38, 0xbf, 0x49,
	0x31, 0x39, 0x94, 0x81, 0x1a, 0x49, 0x23, 0x5f, 0x69, 0x13, 0x9c, 0x2d, 0x9d, 0x5d, 0x68, 0x2d,
	0x02, 0xdf, 0xb5, 0xf6, 0xac, 0x61, 0x7b, 0xbf, 0xfd, 0xe5, 0x3f, 0x1e, 0x7d, 0xe0, 0x11, 0xe0,
	0xb8, 0xd0, 0x56, 0x32, 0x42, 0xd7, 0xde, 0xb3, 0x86, 0xbd, 0x5c, 0xc0, 0x88, 0xf3, 0x00, 0x36,
	0xa6, 0x3a, 0x50, 0xa9, 0xdb, 0xaa, 0xbd, 0x93, 0x41, 0x24, 0xf3, 0x03, 0x19, 0xa5, 0x6e, 0xbb,
	0x2e, 0x63, 0x48, 0x7c, 0x02, 0x9b, 0x27, 0x38, 0x35, 0x3a, 0xf9, 0x89, 0xe3, 0x80, 0x75, 0xc9,
	0x26, 0xed, 0x5c, 0xc5, 0xba, 0x24, 0x6c, 0xc9, 0xd6, 0x4a, 0x6c, 0x49, 0xd8, 0xe7, 0x6c, 0xa6,
	0xc4, 0x3e, 0x17, 0x5f, 0x58, 0xd0, 0x3d, 0xfe, 0xfd, 0xd1, 0xe9, 0x1b, 0x9c, 0x1a, 0xe7, 0x21,
	0x74, 0x4e, 0x65, 0x8a, 0x79, 0x00, 0xdb, 0xb9, 0x56, 0x8e, 0x91, 0xd4, 0xcc, 0x83, 0x34, 0xf0,
	0xf9, 0xbb, 0x85, 0x3b, 0x39, 0x96, 0xc5, 0xb1, 0x50, 0x86, 0x0d, 0x6c, 0x57, 0x71, 0x2c, 0x14,
	0x7d, 0xb7, 0x37, 0x5b, 0xa8, 0x04, 0xcf, 0x74, 0x12, 0xb9, 0xed, 0xbd, 0xd6, 0x70, 0xdb, 0xab,
	0x00, 0xb6, 0xba, 0x08, 0x43, 0x34, 0xee, 0x46, 0xc3, 0x2a, 0x63, 0x8e, 0x80, 0x5e, 0x82, 0xfe,
	0x62, 0x8a, 0xbe, 0x8c, 0xdc, 0x4e, 0x4d, 0xa1, 0x82, 0xc5, 0x7f, 0x6c, 0xb8, 0x77, 0x30, 0x4f,
	0xe4, 0xd4, 0x50, 0x41, 0x62, 0xaa, 0xc7, 0x58, 0x9d, 0xe9, 0x6f, 0x57, 0x8d, 0x10, 0x2f, 0x30,
	0x6c, 0x46, 0xc1, 0x90, 0xf3, 0x03, 0x68, 0xc5, 0x3a, 0xab, 0x45, 0xff, 0xe3, 0xef, 0x3d, 0x2b,
	0x98, 0xf0, 0x2c, 0x2f, 0x83, 0x47, 0x52, 0x67, 0x00, 0x9b, 0xd1, 0x45, 0x1a, 0x23, 0xfa, 0x1c,
	0x4d, 0x91, 0xe9, 0x02, 0x24, 0x03, 0x91, 0xbc, 0x9c, 0xc7, 0x8d, 0x50, 0x32, 0xc8, 0xb9, 0x0f,
	0xf6, 0x3c, 0x76, 0x37, 0x6b, 0x02, 0x7b, 0x1e, 0x3b, 0x8f, 0xa1, 0xaf, 0x93, 0x00, 0x95, 0x91,
	0x26, 0xd0, 0xca, 0xed, 0xd6, 0xbe, 0x5a, 0x17, 0x38, 0x4f, 0xa0, 0xf3, 0x0e, 0x65, 0xac, 0x95,
	0xdb, 0x63, 0x0f, 0x9d, 0xca, 0xc3, 0xa2, 0xc0, 0x5e, 0xae, 0xe1, 0x7c, 0x04, 0xbd, 0x14, 0xa7,
	0xb9, 0x3a, 0x5c, 0xab, 0x5e, 0x29, 0x39, 0xbb, 0xd0, 0x91, 0x49, 0xa4, 0x93, 0xd4, 0xed, 0x73,
	0xfd, 0xf2, 0x27, 0xf1, 0x29, 0xc0, 0xc1, 0x5c, 0x9a, 0x9c, 0xfe, 0x03, 0xd8, 0x9c, 0x6a, 0x65,
	0x50, 0x19, 0x4e, 0x7a, 0x91, 0xdb, 0x02, 0xa4, 0xc4, 0x9b, 0x65, 0x9c, 0x25, 0xbe, 0x88, 0x91,
	0x11, 0xf1, 0x67, 0x0b, 0xe0, 0xb7, 0x5a, 0x61, 0xfe, 0xa1, 0x42, 0xd1, 0x5a, 0x55, 0x74, 0x7e,
	0x04, 0x9d, 0x29, 0x2a, 0x83, 0x09, 0x7f, 0x64, 0x6d, 0x21, 0x72, 0x05, 0x22, 0x56, 0x22, 0xfd,
	0x60, 0x91, 0x36, 0x48, 0x9f, 0x63, 0xce, 0x1e, 0x74, 0x03, 0x52, 0xbb, 0x90, 0x21, 0xd7, 0xb4,
	0x30, 0x53, 0xa2, 0xe2, 0x00, 0xee, 0x1c, 0xcc, 0xa5, 0x9a, 0xe1, 0x3e, 0x53, 0xd1, 0xc3, 0x73,
	0xf2, 0xeb, 0x6c, 0x11, 0x86, 0xec, 0x57, 0xb7, 0xf0, 0x8b, 0x10, 0xe2, 0x1a, 0xb1, 0xa3, 0x1e,
	0x19, 0x01, 0xe2, 0xc5, 0xea, 0x47, 0xcc, 0xb5, 0xb4, 0xac, 0x0e, 0x82, 0x7d, 0xf5, 0x20, 0x88,
	0xbf, 0x59, 0xb0, 0x73, 0x8c, 0x32, 0x3a, 0xc4, 0xe8, 0x14, 0x93, 0x6f, 0xc9, 0xef, 0x3d, 0xe8,
	0x46, 0x18, 0x4d, 0x8c, 0x34, 0xd8, 0xa0, 0x78, 0x89, 0x32, 0x81, 0xb5, 0x8f, 0x61, 0xe0, 0x37,
	0xba, 0x4e, 0x01, 0xe6, 0x69, 0xd3, 0x26, 0x88, 0x90, 0x19, 0xde, 0xaa, 0xa5, 0x8d, 0x51, 0xb2,
	0x9e, 0x86, 0xda, 0x34, 0x18, 0xce, 0x88, 0xf8, 0xa3, 0x0d, 0x77, 0x26, 0x4b, 0x35, 0xa5, 0x30,
	0x28, 0x00, 0x4a, 0xc6, 0x7d, 0xb0, 0x57, 0x42, 0xb0, 0x03, 0x9f, 0x4e, 0xbd, 0x41, 0x99, 0x3b,
	0x5a, 0xcf, 0x46, 0x05, 0x3b, 0xbf, 0x00, 0x88, 0x38, 0x17, 0x81, 0x3a, 0xd3, 0x6e, 0x6b, 0xaf,
	0x35, 0xec, 0x7f, 0xec, 0xd6, 0x58, 0xdc, 0xc8, 0x95, 0x57, 0xd3, 0xa5, 0x18, 0x42, 0x94, 0x3e,
	0x26, 0x2b, 0x41, 0x96, 0x28, 0x69, 0x90, 0x21, 0xe6, 0x60, 0xbd, 0x2b, 0x95, 0x28, 0x79, 0x28,
	0x17, 0x46, 0x47, 0xd2, 0x4c, 0xe7, 0xcd, 0xbe, 0x54, 0xc2, 0xd9, 0x61, 0x8f, 0x03, 0xbf, 0x71,
	0xa6, 0x33, 0x48, 0xfc, 0xc5, 0x82, 0x5d, 0xca, 0x85, 0xa7, 0x75, 0x44, 0xae, 0xbe, 0x0e, 0xe5,
	0x12, 0x93, 0xb1, 0xc1, 0xe8, 0x9a, 0x94, 0x64, 0xdd, 0xc1, 0x5e, 0xe9, 0x0e, 0x79, 0x53, 0x6a,
	0xdd, 0xd8, 0x94, 0x1e, 0xc0, 0x46, 0xca, 0x99, 0xac, 0xf3, 0x3c, 0x83, 0x9c, 0x1f, 0x42, 0x3b,
	0xd1, 0x46, 0x72, 0x94, 0x6b, 0xbf, 0xc0, 0x62, 0xf1, 0x6b, 0xb8, 0x37, 0x59, 0x46, 0xa5, 0xb7,
	0x45, 0xf5, 0x7e, 0x0a, 0xed, 0xc0, 0x60, 0xe4, 0x5a, 0x9c, 0xfd, 0xbd, 0xea, 0xed, 0xf5, 0xa1,
	0x79, 0xac, 0x2d, 0x4e, 0xa0, 0x4b, 0x4f, 0xaf, 0x13, 0x1d, 0x7f, 0xcd, 0x9d, 0x93, 0xa5, 0xc2,
	0x5e, 0x49, 0xc5, 0x2e, 0xb4, 0xd4, 0x22, 0x6a, 0x10, 0x98, 0x00, 0x31, 0x81, 0x7b, 0x1e, 0x9e,
	0x25, 0x98, 0xce, 0xf7, 0xf5, 0xe5, 0xd1, 0xe9, 0x9b, 0xbc, 0x99, 0xac, 0xcf, 0xe7, 0x63, 0x68,
	0xfb, 0xd2, 0x48, 0xd7, 0x66, 0xd7, 0x6b, 0xed, 0xaf, 0x70, 0xcd, 0x63, 0xb9, 0x88, 0xa1, 0xfb,
	0x19, 0x4a, 0xff, 0x16, 0xce, 0x36, 0xae, 0x2a, 0x7b, 0xed, 0x55, 0x45, 0x3a, 0x91, 0xbc, 0xcc,
	0x9e, 0x1b, 0x01, 0x54, 0x30, 0x59, 0xdc, 0xd7, 0xfe, 0xf2, 0xff, 0x68, 0xf1, 0x29, 0x6c, 0xed,
	0xcb, 0xe9, 0xdb, 0xd7, 0xf4, 0xef, 0x6b, 0xad, 0x8a, 0xaf, 0x6c, 0xd8, 0xc9, 0x6a, 0xea, 0xe1,
	0x2c, 0x48, 0xa9, 0xd5, 0x0a, 0xe8, 0xbd, 0x90, 0x11, 0x4e, 0x2e, 0x92, 0xf1, 0xa8, 0xd1, 0xfa,
	0x2b, 0x98, 0x2e, 0xb2, 0x91, 0xf9, 0xe4, 0x02, 0x95, 0x39, 0x0e, 0x56, 0x9a, 0x53, 0x5d, 0xe0,
	0x7c, 0x08, 0x70, 0x42, 0x6f, 0x3d, 0x8f, 0xe3, 0xf1, 0x88, 0x3d, 0x2e, 0xd4, 0x6a, 0x38, 0xb9,
	0xf8, 0x3a, 0x94, 0x66, 0x3c, 0x6a, 0x90, 0x3a, 0xc7, 0xc8, 0xd6, 0x98, 0xae, 0x93, 0xe7, 0x09,
	0xca, 0xf1, 0xa8, 0x71, 0x84, 0xeb, 0x02, 0xea, 0x76, 0x27, 0x47, 0x31, 0xaa, 0xf1, 0x88, 0xcf,
	0x70, 0x79, 0x61, 0xe5, 0x20, 0x7d, 0xe7, 0x18, 0x43, 0x9c, 0xea, 0xe8, 0x28, 0xc6, 0x84, 0xcf,
	0x71, 0xe9, 0x73, 0x4d, 0x40, 0x3e, 0x7b, 0x38, 0xa3, 0x46, 0xaf, 0x30, 0xe4, 0x3b, 0xba, 0xf4,
	0xb9, 0xc2, 0x9d, 0x21, 0x6c, 0xbd, 0xd4, 0xb3, 0x40, 0x15, 0x7a, 0xbd, 0x9a, 0x5b, 0x0d, 0x89,
	0xf8, 0x57, 0x1b, 0xfa, 0x59, 0x8a, 0x19, 0xfe, 0xce, 0xe6, 0xf7, 0x01, 0x6c, 0xbc, 0xe4, 0x79,
	0xab, 0xd1, 0x21, 0x19, 0x72, 0x3e, 0x82, 0xbb, 0x59, 0x0a, 0x3e, 0xa5, 0x29, 0xc7, 0x4f, 0x5f,
	0x2d, 0x22, 0xce, 0x6c, 0xa1, 0x76, 0x45, 0xea, 0x3c, 0x81, 0xed, 0x83, 0x90, 0x26, 0xa2, 0x13,
	0x4c, 0xd2, 0x20, 0x9f, 0x84, 0x0a, 0x9b, 0x4d, 0x91, 0xf3, 0x14, 0x76, 0x26, 0xcb, 0xd4, 0x60,
	0xf4, 0x99, 0x4c, 0xfc, 0x77, 0x32, 0x41, 0x9e, 0x83, 0x0a, 0xe5, 0x15, 0xd9, 0x2a, 0x0f, 0xfa,
	0xd7, 0xf1, 0x60, 0x00, 0x9b, 0xaf, 0xd0, 0xbc, 0xd3, 0xc9, 0x5b, 0x77, 0xab, 0x1e, 0x6f, 0x0e,
	0x5e, 0x61, 0xc0, 0xf6, 0x75, 0x0c, 0xe0, 0xcc, 0x79, 0x3a, 0xc4, 0xf1, 0xc8, 0xdd, 0x69, 0x64,
	0x2e, 0x03, 0x89, 0x11, 0xfc, 0xe7, 0x2b, 0xba, 0xe8, 0xef, 0xd4, 0x19, 0x51, 0xc2, 0x2b, 0xac,
	0xbc, 0xbb, 0x9e, 0x95, 0xe2, 0xbf, 0x2d, 0xd8, 0x2a, 0xb9, 0xa6, 0x17, 0xe6, 0x3b, 0x4b, 0xb6,
	0x0f, 0x01, 0x8e, 0x54, 0x18, 0x28, 0x64, 0x97, 0xeb, 0x8c, 0xab, 0xe1, 0x15, 0x25, 0xbb, 0xb7,
	0xa3, 0x64, 0xef, 0x9b, 0x51, 0x12, 0xbe, 0x09, 0x25, 0xfb, 0xb7, 0xa7, 0xe4, 0xd6, 0x2d, 0x28,
	0xb9, 0xbd, 0x86, 0x92, 0xe2, 0x97, 0x00, 0x87, 0x32, 0x08, 0xf3, 0x15, 0xb0, 0xba, 0x2b, 0xb7,
	0xaf, 0x5e, 0xb8, 0xf6, 0xea, 0x85, 0xfb, 0x85, 0x0d, 0x5d, 0x7a, 0x99, 0xa7, 0xd1, 0x87, 0xd0,
	0x89, 0x64, 0x10, 0xae, 0x5c, 0xb5, 0x39, 0xc6, 0x93, 0xa7, 0x0c, 0xc2, 0x2b, 0xe3, 0x7f, 0x89,
	0x92, 0xa3, 0x33, 0x34, 0x3c, 0x58, 0xd6, 0x77, 0xe1, 0x02, 0xa4, 0x2f, 0xcc, 0xe5, 0x05, 0x26,
	0x28, 0xb3, 0xa9, 0xad, 0x98, 0xbf, 0x4b, 0x94, 0x4a, 0x67, 0x02, 0x13, 0x66, 0x23, 0x5b, 0x11,
	0x68, 0x06, 0xf1, 0x46, 0x81, 0x97, 0xa6, 0xc1, 0x0c, 0x46, 0x78, 0x8a, 0x4e, 0xc2, 0x46, 0x6f,
	0x27, 0xc0, 0x19, 0x42, 0x5b, 0x9f, 0xbe, 0x49, 0xdd, 0x2e, 0x0f, 0x08, 0xf7, 0xab, 0x01, 0xa1,
	0x4a, 0x97, 0xc7, 0x1a, 0xe4, 0x39, 0xf9, 0x30, 0x43, 0xc3, 0x6c, 0x28, 0x1c, 0x2b, 0xc0, 0x6c,
	0xb0, 0x37, 0x66, 0xa5, 0xfa, 0x39, 0x26, 0xee, 0xc2, 0x8e, 0x87, 0xe7, 0x2f, 0xd0, 0xd0, 0x77,
	0x5f, 0x06, 0xa9, 0x11, 0x3f, 0x87, 0xbe, 0x57, 0x3d, 0x3a, 0x43, 0x1a, 0x23, 0x83, 0x30, 0xcd,
	0xa7, 0x2c, 0xa7, 0xe9, 0x09, 0x8f, 0x62, 0x99, 0x82, 0xf8, 0x31, 0xbd, 0x78, 0x7e, 0xbb, 0x8a,
	0x88, 0x9f, 0x95, 0x56, 0x58, 0xf9, 0x31, 0xb4, 0x49, 0xc0, 0xaa, 0xeb, 0x8d, 0xb0, 0x5c, 0xfc,
	0xd5, 0x82, 0xad, 0xe7, 0x4a, 0x2d, 0xb4, 0x9a, 0x22, 0xbf, 0x78, 0xed, 0x04, 0x9f, 0x1a, 0x99,
	0x54, 0xed, 0xa1, 0x58, 0x14, 0x2a, 0x98, 0xf2, 0x86, 0xca, 0x3f, 0x2e, 0x2a, 0x5e, 0x68, 0x14,
	0x20, 0x75, 0x4b, 0x5e, 0xc6, 0x94, 0x0c, 0x59, 0xa9, 0x5d, 0x53, 0x6a, 0x48, 0xea, 0x8b, 0xe7,
	0xc6, 0x9a, 0xc5, 0x53, 0x3c, 0x87, 0x7b, 0x63, 0x15, 0x98, 0xba, 0xdf, 0x34, 0xbe, 0x3e, 0x69,
	0x8c, 0xaf, 0xbb, 0x55, 0xcc, 0x0d, 0xc5, 0x6c, 0x68, 0xfd, 0xb7, 0x05, 0x90, 0x1d, 0xec, 0x1b,
	0xa2, 0xbe, 0xf1, 0x97, 0x85, 0xf4, 0xca, 0xda, 0x95, 0xcf, 0xe0, 0xc4, 0xcd, 0x22, 0xbe, 0x6a,
	0xdb, 0xa5, 0xb8, 0x72, 0x6e, 0x6e, 0xac, 0x72, 0x53, 0x40, 0x8f, 0x77, 0xdc, 0x38, 0x94, 0x4d,
	0x4a, 0x57, 0x30, 0x59, 0x3c, 0x3f, 0xbf, 0x08, 0x9a, 0xbf, 0x28, 0x64, 0x10, 0x9d, 0x25, 0x15,
	0x4c, 0xdf, 0xb2, 0xaf, 0xf5, 0x69, 0xa5, 0x44, 0xc5, 0x53, 0x70, 0xa8, 0xfd, 0x66, 0x11, 0xf3,
	0xc2, 0x45, 0xfb, 0xef, 0x2e, 0x74, 0x74, 0x8c, 0x8a, 0x23, 0x6f, 0x0d, 0x7b, 0x5e, 0xfe, 0x24,
	0x52, 0xf8, 0xfe, 0x4b, 0x7d, 0x7a, 0xaa, 0x97, 0x93, 0x29, 0x2a, 0xcc, 0xd6, 0xae, 0x49, 0xa8,
	0xaf, 0xdf, 0x75, 0x07, 0xb0, 0x49, 0x2b, 0xe1, 0xd8, 0xbf, 0x6c, 0x74, 0x83, 0x02, 0xe4, 0xc9,
	0x56, 0x87, 0x78, 0x48, 0x5b, 0x67, 0xe3, 0xda, 0xa8, 0x60, 0x61, 0xe0, 0x11, 0xad, 0x19, 0x57,
	0x0c, 0xa7, 0x64, 0x39, 0xbd, 0xa1, 0x4a, 0xbf, 0x82, 0x6e, 0xaa, 0x43, 0x43, 0x87, 0x2b, 0x1f,
	0xff, 0x1f, 0x55, 0xa5, 0x5f, 0x1b, 0x87, 0x57, 0xbe, 0x20, 0x7e, 0x07, 0x03, 0x0f, 0xcf, 0xb3,
	0x9d, 0x7e, 0x7d, 0xcc, 0xb5, 0xd8, 0xac, 0x75, 0xb1, 0x3d, 0x84, 0x0e, 0xad, 0x91, 0xe3, 0xd1,
	0xca, 0x0f, 0x69, 0x8c, 0xed, 0xdf, 0xfd, 0xf2, 0xfd, 0xc0, 0xfa, 0xfb, 0xfb, 0x81, 0xf5, 0xd5,
	0xfb, 0x81, 0xf5, 0xa7, 0x7f, 0x0e, 0x3e, 0xf8, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x04, 0x03,
	0x0c, 0x69, 0x81, 0x14, 0x00, 0x00,
}
